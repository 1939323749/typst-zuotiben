[
  {
    "question": "冯·诺依曼计算机的核心思想是(  )",
    "options": [
      "A. 存储程序控制",
      "B. 以二进制表示信息",
      "C. 以运算器为核心",
      "D. 数据流驱动方式"
    ],
    "chapter": "1.1计算机系统层次结构",
    "id": 1,
    "image": ""
  },

  {
    "question": "以下有关冯·诺依曼计算机的叙述中，正确的是( )",
    "options": [
      "A. 程序和数据以同等地位放入存储器中，CPU根据指令周期的不同阶段来区分指令和数据",
      "B. 指令和数据可以从形式上区分",
      "C. 指令以二进制形式存放，数据以十进制形式存放",
      "D. 指令存放在控制器中，数据存放在存储器中"
    ],
    "chapter": "1.1计算机系统层次结构",
    "id": 2,
    "image": ""
  },
  {
    "question": "以下有关冯·诺依曼计算机的叙述中，错误的是( )",
    "options": [
      "A. 指令由操作码和地址码两部分组成",
      "B. 指令和数据存放在存储器中，按地址访问",
      "C. 指令按地址访问，所有数据在指令中直接给出",
      "D. 计算机硬件系统由运算器、存储器、控制器、输入设备和输出设备5大部件组成"
    ],
    "chapter": "1.1计算机系统层次结构",
    "id": 3,
    "image": ""
  },
  {
    "question": "早期的冯·诺依曼计算机是以( )为核心的",
    "options": ["A. 运算器", "B. 控制器", "C. 存储器", "D. 输入输出设备"],
    "chapter": "1.1计算机系统层次结构",
    "id": 4,
    "image": ""
  },
  {
    "question": "以下有关计算机各功能部件的叙述中，错误的是( )",
    "options": [
      "A. 输入输出设备的主要功能是完成用户与计算机之间的信息交互",
      "B. 运算器的主要功能是完成算术运算",
      "C. 控制器的主要功能是从内存取指令和执行指令",
      "D. 存储器的主要功能是存放程序和数据"
    ],
    "chapter": "1.1计算机系统层次结构",
    "id": 5,
    "image": ""
  },
  {
    "question": "在主机中能对指令进行译码的器件是( )",
    "options": ["A. MAR", "B. ALU", "C. 控制器", "D. MDR"],
    "chapter": "1.1计算机系统层次结构",
    "id": 6,
    "image": ""
  },
  {
    "question": "计算机的算术逻辑单元、控制单元及存储器合称为( ). ",
    "options": ["A. CPU", "B. 主机", "C. ALU", "D. CU"],
    "chapter": "1.1计算机系统层次结构",
    "id": 7,
    "image": ""
  },
  {
    "question": "完整的计算机系统应包括(  )",
    "options": [
      "A. 计算机硬件与软件系统",
      "B. CPU和存储器",
      "C. 控制单元和算术逻辑单元",
      "D. 主机、鼠标、键盘和显示屏"
    ],
    "chapter": "1.1计算机系统层次结构",
    "id": 8,
    "image": ""
  },
  {
    "question": "计算机系统的输入输出接口是( )之间的交接界面. ",
    "options": [
      "A. CPU与存储器",
      "B. 主机与外围设备",
      "C. 存储器与外围设备",
      "D. CPU与系统总线"
    ],
    "chapter": "1.1计算机系统层次结构",
    "id": 9,
    "image": ""
  },
  {
    "question": "计算机系统包括软件系统和硬件系统，其中软件又可以分为( )",
    "options": [
      "A. 高级语言程序和低级语言程序",
      "B. 系统软件和应用软件",
      "C. 操作系统和应用软件",
      "D. 系统软件和高级语言程序"
    ],
    "chapter": "1.1计算机系统层次结构",
    "id": 10,
    "image": ""
  },
  {
    "question": "下列选项中，( )属于应用软件",
    "options": ["A. 操作系统", "B. 编译系统", "C. 链接程序", "D. 文本处理"],
    "chapter": "1.1计算机系统层次结构",
    "id": 11,
    "image": ""
  },
  {
    "question": "以下说法中，正确的是( ). ",
    "options": [
      "A. 软硬件在逻辑上是等效的",
      "B. 软件实现的功能一般比硬件实现具有更高的执行速度",
      "C. 硬件可以脱离软件单独运行",
      "D. 硬件实现的功能无法用软件取代"
    ],
    "chapter": "1.1计算机系统层次结构",
    "id": 12,
    "image": ""
  },
  {
    "question": "计算机系统从上到下的层次化构成为",
    "options": [
      "A. 机器语言机器--操作系统虚拟机--汇编语言虚拟机--高级语言虚拟机",
      "B. 高级语言虚拟机--操作系统虚拟机--汇编语言虚拟机--机器语言机器",
      "C. 高级语言虚拟机--汇编语言虚拟机--机器语言机器--操作系统虚拟机",
      "D. 高级语言虚拟机--汇编语言虚拟机-- 操作系统虚拟机--机器语言机器"
    ],
    "chapter": "1.1计算机系统层次结构",
    "id": 13,
    "image": ""
  },
  {
    "question": "直接执行微指令的是(  )",
    "options": ["A. 翻译程序", "B. 微指令程序", "C. 系统软件", "D. 硬件"],
    "chapter": "1.1计算机系统层次结构",
    "id": 14,
    "image": ""
  },
  {
    "question": "计算机系统各层次之间的关系为",
    "options": [
      "A. 上下层之间毫无关系",
      "B. 上层与下层相互依存、不可分割",
      "C. 下层是实现上层的基础，而上层实现对下层的功能拓展",
      "D. 上层是实现下层的基础，而下层实现对上层的功能拓展"
    ],
    "chapter": "1.1计算机系统层次结构",
    "id": 15,
    "image": ""
  },
  {
    "question": "( )可以区分存储单元中存放的是指令还是数据. ",
    "options": ["A. 控制器", "B. 运算器", "C. 用户", "D. 输入输出设备"],
    "chapter": "1.1计算机系统层次结构",
    "id": 16,
    "image": ""
  },
  {
    "question": "计算机区别于其他计算工具的最本质的特点是(  )",
    "options": [
      "A. 自动连续地执行程序",
      "B. 运算速度快",
      "C. 运算精度高",
      "D. 存储能力强"
    ],
    "chapter": "1.1计算机系统层次结构",
    "id": 17,
    "image": ""
  },
  {
    "question": "下列说法中，错误的是( ). ",
    "options": [
      "A. 可用高级语言和低级语言编写出功能等价的程序",
      "B. 低级语言的执行效率一般情况下高于高级语言",
      "C. 机器语言源程序可以在机器上直接执行，而高级语言和汇编语言源程序不可以",
      "D. 汇编语言与机器结构无关"
    ],
    "chapter": "1.1计算机系统层次结构",
    "id": 18,
    "image": ""
  },
  {
    "question": "只有当程序要执行时，它才会去将源程序翻译成机器语言，而且翻译一句执行一句，此程序称为( ). ",
    "options": ["A. 翻译程序", "B. 解释程序", "C. 编译程序", "D. 汇编程序"],
    "chapter": "1.1计算机系统层次结构",
    "id": 19,
    "image": ""
  },
  {
    "question": "【2009】冯·诺依曼计算机中指令和数据均以二进制形式存放在存储器中，CPU区分它们的依据是(  )",
    "options": [
      "A. 指令操作码的译码结果",
      "B. 指令和数据的寻址方式",
      "C. 指令周期的不同阶段",
      "D. 指令和数据所在的存储单元"
    ],
    "chapter": "1.1计算机系统层次结构",
    "id": 20,
    "image": ""
  },
  {
    "question": "【2015】计算机硬件能够直接执行的是( ). \nI.机器语言程序\nII.汇编语言程序\nIII.硬件描述语言程序",
    "options": ["A. 仅I", "B. 仅I、II", "C. 仅I、III", "D. I、II和III"],
    "chapter": "1.1计算机系统层次结构",
    "id": 21,
    "image": ""
  },
  {
    "question": "【2016】将高级语言源程序转换为机器级目标代码文件的程序是(  )",
    "options": ["A. 汇编程序", "B. 链接程序", "C. 编译程序", "D. 解释程序"],
    "chapter": "1.1计算机系统层次结构",
    "id": 22,
    "image": ""
  },
  {
    "question": "【2019】下列关于冯·诺依曼计算机基本思想的叙述中，错误的是",
    "options": [
      "A. 程序的功能都通过中央处理器执行指令实现",
      "B. 指令和数据都用二进制数表示，形式上无差别",
      "C. 指令按地址访问，数据都在指令中直接给出",
      "D. 程序执行前，指令和数据需预先存放在存储器中"
    ],
    "chapter": "1.1计算机系统层次结构",
    "id": 23,
    "image": ""
  },
  {
    "question": "计算机中最小单位时间是(  )",
    "options": ["A. 时钟周期", "B. 指令周期", "C. CPU周期", "D. 执行周期"],
    "chapter": "1.2计算机性能指标",
    "id": 1,
    "image": ""
  },
  {
    "question": "下列有关计算机性能指标MIPS的描述中，错误的是",
    "options": [
      "A. MIPS是指平均每秒执行的百万条指令数",
      "B. MIPS越大说明机器性能一定越好",
      "C. 用MIPS对不同机器进行性能比较不太客观",
      "D. MIPS反映的是机器执行定点指令的速度"
    ],
    "chapter": "1.2计算机性能指标",
    "id": 2,
    "image": ""
  },
  {
    "question": "CPU的CPI与下列哪个因素无关( ). ",
    "options": ["A. 时钟周期", "B. 系统结构", "C. 指令集", "D. 计算机组织"],
    "chapter": "1.2计算机性能指标",
    "id": 3,
    "image": ""
  },
  {
    "question": "下列关于CPU主频、CPI、MIPS、MFLOPS的说法中，错误的是( )",
    "options": [
      "A. CPU主频是指CPU系统执行指令的频率",
      "B. CPI是指执行一条指令所需要的时钟周期数",
      "C. MIPS是指每秒执行多少百万条指令",
      "D. MFLOPS是指每秒执行多少百万次浮点运算"
    ],
    "chapter": "1.2计算机性能指标",
    "id": 4,
    "image": ""
  },
  {
    "question": "以下4种措施中，无法改善计算机性能的是( ). ",
    "options": [
      "A. 降低CPU时钟频率",
      "B. 使用更快的处理器来替换原来的慢速处理器",
      "C. 增加同类处理器个数，使不同的处理器同时执行程序",
      "D. 优化编译生成的代码，使得程序执行的总时钟周期数减少"
    ],
    "chapter": "1.2计算机性能指标",
    "id": 5,
    "image": ""
  },
  {
    "question": "计算机A的时钟频率为800MHz，某程序在计算机A上运行需要12秒，在计算机B上运行需要8s，但在计算机B上运行该程序所需的时钟周期数为计算机A上的1.5倍，那么计算机B的时钟频率为(  )",
    "options": ["A. 1.8MHz", "B. 800MHz", "C. 1.2GHz", "D. 1.8GHz"],
    "chapter": "1.2计算机性能指标",
    "id": 6,
    "image": ""
  },
  {
    "question": "计算机A的时钟周期为2.4ns，计算机B的时钟周期为4ns. 某个程序在计算机A上运行时的CPI为4，在计算机B上运行时的CPI为2. 则对于该程序来说，计算机A和计算机B之间的速度关系为( ) ",
    "options": [
      "A. 计算机A比计算机B快1.2倍",
      "B. 计算机B比计算机A快1.2倍",
      "C. 计算机A的速度是计算机B的1.2倍",
      "D. 计算机B的速度是计算机A的1.2倍"
    ],
    "chapter": "1.2计算机性能指标",
    "id": 7,
    "image": ""
  },
  {
    "question": "已知一台时钟频率为4GHz的计算机的CPI为5，某程序P在该计算机上的指令条数为2×10<sup>9</sup>条. 若在该计算机上，程序P从开始启动到执行结束所经历的时间是10s，则运行P所用CPU 时间占整个CPU时间的百分比大约是(  )",
    "options": ["A. 50%", "B. 40%", "C. 25%", "D. 20%"],
    "chapter": "1.2计算机性能指标",
    "id": 8,
    "image": ""
  },
  {
    "question": "假定编译器对高级语言的某条语句可以编译生成两种不同的指令序列，A、B和C三类指令的 CPI和两种不同序列中所含的三类指令的条数如下表所示，以下结论中正确的是(  )",
    "options": [
      "A. 序列一的指令条数少于序列二的指令条数",
      "B. 序列一的执行速度比序列二慢",
      "C. 序列一的总时钟周期数比序列二少",
      "D. 序列一的CPI比序列二的CPI小"
    ],
    "chapter": "1.2计算机性能指标",
    "id": 9,
    "image": "/image/1_2_9.png"
  },
  {
    "question": "假定编译器对高级语言的某条语句可以编译生成两种不同的指令序列，A、B和C三类指令的 CPI和两种不同序列中所含的三类指令的条数如下表所示，两个指令序列都在时钟周期为2ns 的机器上运行，以下结论中正确的是(  )",
    "options": [
      "A. 序列一的MIPS数比序列二多50，序列一的执行速度比序列二快10ns",
      "B. 序列一的MIPS数比序列二多50，序列二的执行速度比序列一快10ns",
      "C. 序列二的MIPS数比序列一多50，序列一的执行速度比序列二快10ns",
      "D. 序列二的MIPS数比序列一多50，序列二的执行速度比序列一快10ns"
    ],
    "chapter": "1.2计算机性能指标",
    "id": 10,
    "image": "/image/1_2_10.png"
  },
  {
    "question": "假定某程序P由一个2000条指令构成的循环组成，该循环共执行10次，在某系统S中执行程序P花了50000个时钟周期，则系统S在执行程序P时的CPI为(  )",
    "options": ["A. 0.4", "B. 2.5", "C. 4", "D. 25"],
    "chapter": "1.2计算机性能指标",
    "id": 11,
    "image": ""
  },
  {
    "question": "假定执行指令A需要20个时钟周期，该指令在程序中的出现频度为20%，其他所有指令的平均CPI为5，则CPU执行指令A所用时间占整个CPU时间的百分比是多少？( ). ",
    "options": ["A. 20%", "B. 50%", "C. 80%", "D. 25%"],
    "chapter": "1.2计算机性能指标",
    "id": 12,
    "image": ""
  },
  {
    "question": "下列语句中，正确的是(  )",
    "options": [
      "A. 1MB=1000B",
      "B. 1MB=1000KB",
      "C. 1MB=1024×1024B",
      "D. 1MB=2<sup>6</sup>B"
    ],
    "chapter": "1.2计算机性能指标",
    "id": 13,
    "image": ""
  },
  {
    "question": "计算机的字长是指(  )",
    "options": [
      "A. 32位长的数据",
      "B. CPU数据总线的宽度",
      "C. 计算机内部一次可以处理的二进制数据的位数",
      "D. CPU地址总线的宽度"
    ],
    "chapter": "1.2计算机性能指标",
    "id": 14,
    "image": ""
  },
  {
    "question": "存储字是指(  )",
    "options": [
      "A. 存放在一个存储单元中的二进制代码组合",
      "B. 存放在一个存储单元中的二进制代码位数",
      "C. 存储单元的个数",
      "D. 存储容量的字节个数"
    ],
    "chapter": "1.2计算机性能指标",
    "id": 15,
    "image": ""
  },
  {
    "question": "存储字长是指( ). ",
    "options": [
      "A. 存放在一个存储单元中的二进制代码组合",
      "B. 存放在一个存储单元中的二进制代码位数",
      "C. 存储单元的个数",
      "D. 存储容量的字节个数"
    ],
    "chapter": "1.2计算机性能指标",
    "id": 16,
    "image": ""
  },
  {
    "question": "下列选项中，能缩短程序执行时间的措施是( ). \nI. 提高CPU时钟频率 \nII. 优化数据通路结构\nIII. 对程序进行编译优化",
    "options": ["A. 仅I和II", "B. 仅I和III", "C. 仅II和III", "D. I、II和III"],
    "chapter": "1.2计算机性能指标",
    "id": 20,
    "image": ""
  },
  {
    "question": "下列选项中，描述浮点数操作速度指标的是( )",
    "options": ["A. MIPS", "B. CPI", "C. IPC", "D. MFLOPS"],
    "chapter": "1.2计算机性能指标",
    "id": 21,
    "image": ""
  },
  {
    "question": "假定基准程序A在某计算机上的运行时间为100s，，其中90s为CPU时间，其余为IO 时间. 若CPU速度提高50%，I/O速度不变，则运行基准程序A所耗费的时间是( ). ",
    "options": ["A. 55s", "B. 60s", "C. 65s", "D. 70s"],
    "chapter": "1.2计算机性能指标",
    "id": 22,
    "image": ""
  },
  {
    "question": "某计算机主频为1.2GHz，其指令分为4类，它们在基准程序中所占比例及CPI如下表所示.该机的MIPS数是( ).",
    "options": ["A. 100", "B. 200", "C. 400", "D. 600"],
    "chapter": "1.2计算机性能指标",
    "id": 23,
    "image": "/image/1_2_23.png"
  },
  {
    "question": "程序P在机器M上的执行时间是20秒，编译优化后，P执行的指令数减少到原来的 70%，而CPI增加到原来的1.2倍，则P在M上的执行时间是( ).",
    "options": ["A. 8.4s", "B. 11.7s", "C. 14s", "D. 16.8s"],
    "chapter": "1.2计算机性能指标",
    "id": 24,
    "image": ""
  },
  {
    "question": "假定计算机MI和M2具有相同的指令集体系结构(ISA)，主频分别为1.5GHz和1.2GHz. 在M1和M2上运行某基准程序P，若平均CPI分别为2和1, 则程序P在M1和M2上运行时间的比值是( ).",
    "options": ["A. 0.4", "B. 0.625", "C. 1.6", "D. 2.5"],
    "chapter": "1.2计算机性能指标",
    "id": 25,
    "image": ""
  },
  {
    "question": "下列给出的部件中，其位数(宽度)一定与机器：字长相同的是\nI.ALU\nII.指令寄存器\nIII.通用寄存器\nIV.浮点寄存器",
    "options": ["A. 仅I、II", "B. 仅I、III", "C. 仅II、III", "D. 仅II、IV"],
    "chapter": "1.2计算机性能指标",
    "id": 26,
    "image": ""
  },
  {
    "question": "2017年公布的全球超级计算机TOP500排名中，我国“神威·太湖之光“超级计算机蝉联第一，其浮点运算速度为93.0146 PFLOPS，说明该计算机每秒钟内完成的浮点操作次数约为( ).",
    "options": [
      "A. 9.3×10<sup>13</sup>次",
      "B. 9.3×10<sup>15</sup>",
      "C. 9.3千万亿次",
      "D. 9.3亿亿次"
    ],
    "chapter": "1.2计算机性能指标",
    "id": 27,
    "image": ""
  },
  {
    "question": "引入八进制和十六进制的目的是( ).",
    "options": [
      "A. 节约元器件",
      "B. 可以表示更大范围的数",
      "C. 比二进制运算速度快",
      "D. 便于表示和阅读二进制"
    ],
    "chapter": "2.1数制与编码",
    "id": 1,
    "image": ""
  },
  {
    "question": "107对应的二进制和十六进制形式是( ).",
    "options": [
      "A. 1101010B、6BH",
      "B. 1101011B、6BH",
      "C. 1101100B、6CH",
      "D. 1101101B、6DH"
    ],
    "chapter": "2.1数制与编码",
    "id": 2,
    "image": ""
  },
  {
    "question": "(35A98127)<sub>16</sub> +(B612AC85)<sub>16</sub>=( ) .",
    "options": [
      "A. (17745552242)<sub>8</sub>",
      "B. (35357026654)<sub>8</sub>",
      "C. (36210512022)<sub>8</sub>",
      "D. (37745552242)<sub>8</sub>"
    ],
    "chapter": "2.1数制与编码",
    "id": 3,
    "image": ""
  },
  {
    "question": "下列各种进位计数制的数中，最小的数是( ).",
    "options": [
      "A. (10010111)<sub>2</sub>",
      "B. (77)<sub>8</sub>",
      "C. (107)<sub>10</sub>",
      "D. (3E)<sub>16</sub>"
    ],
    "chapter": "2.1数制与编码",
    "id": 4,
    "image": ""
  },
  {
    "question": "下列关于原码、补码、移码的叙述中，正确的是( ).",
    "options": [
      "A. 计算机使用原码实现加减法",
      "B. 计算机用补码对有符号整数编码",
      "C. 移码通常用来表示浮点数的尾数",
      "D. 原码通常用来表示浮点数的阶"
    ],
    "chapter": "2.1数制与编码",
    "id": 5,
    "image": ""
  },
  {
    "question": "下列有关补码的描述中，正确的是( ).\n\nI.在计算机中用来表示无符号数     II.零的表示形式唯一\nIII.符号位和数值位一起参与运算    IV.实现了加减法的统一\nV.机器数的大小可以直观反映真值的大小",
    "options": [
      "A. 仅I、III、V",
      "B. 仅I、II、III",
      "C. 仅II、III、IV",
      "D. 仅I、II和V"
    ],
    "chapter": "2.1数制与编码",
    "id": 6,
    "image": ""
  },
  {
    "question": "下列有关补码表示的一些常见二进制形式中，错误的力是( ).",
    "options": [
      "A. 补码表示0的二进制为000···00",
      "B. 补码表示-1的二进制为111···11",
      "C. 补码表示的最小整数的形式为100···00",
      "D. 补码表示的最大整数的形式为111···11"
    ],
    "chapter": "2.1数制与编码",
    "id": 7,
    "image": ""
  },
  {
    "question": "下列关于n位补码和移码(偏置常数为2<sup>n-1</sup>)的描述中，错误的是( ).",
    "options": [
      "A. 两者有相同的表示范围",
      "B. 两者对零的表示相同",
      "C. 移码为补码的符号位取反",
      "D. 移码通常表示浮点数的阶"
    ],
    "chapter": "2.1数制与编码",
    "id": 8,
    "image": ""
  },
  {
    "question": "数X在计算机中的机器数为1000 1000，若X=-01111000B，则X的编码方式为( ).",
    "options": ["A. 原码", "B. 补码", "C. 反码", "D. 移码"],
    "chapter": "2.1数制与编码",
    "id": 9,
    "image": ""
  },
  {
    "question": "下列有关编码转换的叙述中，错误的是( ).",
    "options": [
      "A. [X]<sub>原</sub>=01011110，则 [X]<sub>补</sub>=01011110",
      "B. [X]<sub>原</sub>=11011110，则 [X]<sub>补</sub>=10100010",
      "C. [X]<sub>补</sub>=01011110，则 [-X]<sub>补</sub>=10100010",
      "D. [X]<sub>补</sub>=1101110，则 [-X]<sub>补</sub>=10100010"
    ],
    "chapter": "2.1数制与编码",
    "id": 10,
    "image": ""
  },
  {
    "question": "下列机器数中，真值最大的数是( ).",
    "options": [
      "A. [x] = 1101101101",
      "B. [x]<sub>反</sub>=1101101101101",
      "C. [x]<sub>补</sub>=1101101101101",
      "D. [x]<sub>移</sub>=1101101101"
    ],
    "chapter": "2.1数制与编码",
    "id": 11,
    "image": ""
  },
  {
    "question": "完成以下进制转换:",
    "options": [
      "(1) (37.375)<sub>10</sub>=( )<sub>2</sub>=( )<sub>8</sub>=( )<sub>16</sub>",
      "(2) (127.8125)<sub>10</sub>=( )<sub>2</sub>=( )<sub>8</sub>=( )<sub>16</sub>",
      "(3) (1011011.1011)<sub>2</sub>=( )<sub>10</sub>=( )<sub>8</sub>=( )<sub>16</sub>",
      "(4) (AB. C)<sub>16</sub>=( )<sub>10</sub>=( )<sub>8</sub>"
    ],
    "chapter": "2.1数制与编码",
    "id": 12,
    "image": ""
  },
  {
    "question": "使用十六进制会给数的表示和运算带来方便.类比十进制加减法，利用十六进制完成以下算术题.(提示：加减法规则不变，只需将基数改成16即可)\n\n(1) 503CH + 40H = ( )H\n\n(2) 503CH + 10000111B = ( )H\n\n(3) 503CH - 128 = ( )H\n\n(4) 602DH - 503CH = ( )H",
    "options": [],
    "chapter": "2.1数制与编码",
    "id": 13,
    "image": ""
  },
  {
    "question": "用二进制表示下列无符号整数至少需要几位？\n\n107，511，1000，1024，65535",
    "options": [],
    "chapter": "2.1数制与编码",
    "id": 14,
    "image": ""
  },
  {
    "question": "用补码表示下列有符号整数至少需要几位？\n\n-107， +511， +1000， -1024， -65536， +65535",
    "options": [],
    "chapter": "2.1数制与编码",
    "id": 15,
    "image": ""
  },
  {
    "question": "【2018】冯·诺依曼计算机中的数据采用二进制编码表示，其主要原因是( ).\nI.二进制的运算规则简单\nII.制造两个稳态的物理器件较容易\nIII.便于用逻辑门电路实现算术运算",
    "options": ["A. 仅I、II", "B. 仅I、III", "C. 仅II、III", "D. I、II和III"],
    "chapter": "2.1数制与编码",
    "id": 16,
    "image": ""
  },
  {
    "question": "假设寄存器有8位，(-46)<sub>10</sub>以补码形式存放，其中符号位占一位，则存放在寄存器中的内容为( ).",
    "options": ["A. 46H", "B. B2H", "C. D2H", "D. AEH"],
    "chapter": "2.2整数表示和运算",
    "id": 1,
    "image": ""
  },
  {
    "question": "若定点整数有64位，含1位符号位，补码表示，则所能表示的绝对值最大的负数是( ).",
    "options": [
      "A. -2<sup>64</sup>",
      "B. -2<sup>63</sup>",
      "C. -(2<sup>64</sup>-1)",
      "D. -(2<sup>63</sup> - 1)"
    ],
    "chapter": "2.2整数表示和运算",
    "id": 2,
    "image": ""
  },
  {
    "question": "假设一个16位的寄存器，用于存放无符号整数，则它能存放的最大数是( ).",
    "options": ["A. 65535", "B. 65536", "C. 32767", "D. 32768"],
    "chapter": "2.2整数表示和运算",
    "id": 3,
    "image": ""
  },
  {
    "question": "假设一个16位的寄存器，用于存放补码表示的定点整数，则它能存放的整数范围是( ).",
    "options": [
      "A. -65535 ~ +65536",
      "B. -65536 ~ +65535",
      "C. -32768 ~ +32767",
      "D. -32767 ~ +32768"
    ],
    "chapter": "2.2整数表示和运算",
    "id": 4,
    "image": ""
  },
  {
    "question": "若用定点整数表示数据(-134)<sub>10</sub>并存入寄存器中，则寄存器至至少要有( )位.",
    "options": ["A. 8", "B. 9", "C. 10", "D. 16"],
    "chapter": "2.2整数表示和运算",
    "id": 5,
    "image": ""
  },
  {
    "question": "整数x的机器数为C007H，下列说法中错误的是( ).",
    "options": [
      "A. 逻辑左移一位的机器数为800EH",
      "B. 逻辑右移一位的机器数为6003H",
      "C. 算术左移一位的机器数为8003H",
      "D. 算术右移一位的机器数位E003H"
    ],
    "chapter": "2.2整数表示和运算",
    "id": 6,
    "image": ""
  },
  {
    "question": "关于补码右移，说法正确的是( ).",
    "options": [
      "A. 定点数右移1bit，最高位用0补充",
      "B. 定点数右移1bit，最高位用1补充",
      "C. 定点数右移1bit，最高位用原最低位补充",
      "D. 定点数右移1bit，最高位用原符号位补充"
    ],
    "chapter": "2.2整数表示和运算",
    "id": 7,
    "image": ""
  },
  {
    "question": "设机器字长为8位，[x]<sub>补</sub>=10101100，[y]<sub>补</sub>=01000110，[x]<sub>补</sub>-[y]<sub>补</sub>的运算结果是( ).",
    "options": [
      "A. 10100110",
      "B. 01000110",
      "C. 负溢出、出错",
      "D. 正溢出、出错"
    ],
    "chapter": "2.2整数表示和运算",
    "id": 8,
    "image": ""
  },
  {
    "question": "两个有符号整数A、B用8位补码表示.已知A=92, B=-51，则A - B的机器数和溢出标志OF分别为( ).",
    "options": ["A. 29H、0", "B. 29H、1", "C. 8FH、0", "D. 8FH、1"],
    "chapter": "2.2整数表示和运算",
    "id": 9,
    "image": ""
  },
  {
    "question": "某计算机字长为8位，带符号整数A和B用补码表示.已知[A]<sub>补</sub> = B4H、[B]<sub>补</sub>=2EH，则 4A+B/2的机器数为( ).",
    "options": ["A. E7H", "B. BAH", "C. 7FH", "D. DBH"],
    "chapter": "2.2整数表示和运算",
    "id": 10,
    "image": ""
  },
  {
    "question": "在某8位计算机中，两个带符号整数变量x、y的机器考数分别为34H、2DH，则x-2y的机器数以及溢出标志OF分别是( ).",
    "options": ["A. 8EH、0", "B. 8EH、1", "C. DAH、0", "D. DAH、1"],
    "chapter": "2.2整数表示和运算",
    "id": 11,
    "image": ""
  },
  {
    "question": "在某8位计算机中，两个带符号整数变量x、y的机器教分别为34H、CDH，则x/2+2y的机器数以及溢出标志OF分别是( ).",
    "options": ["A. B4H、0", "B. B4H、1", "C. A4H、0", "D. A4H、1"],
    "chapter": "2.2整数表示和运算",
    "id": 12,
    "image": ""
  },
  {
    "question": "在某8位计算机中，两个带符号整数变量r<sub>1</sub>、r<sub>2</sub>的机器数分别别为F4H、E4H，则下列运算中会发生溢出的是( ).",
    "options": [
      "A. r<sub>1</sub>+r<sub>2</sub>",
      "B. r<sub>1</sub>-r<sub>2</sub>",
      "C. r<sub>1</sub>×r<sub>2</sub>",
      "D. r<sub>1</sub>/r<sub>2</sub>"
    ],
    "chapter": "2.2整数表示和运算",
    "id": 13,
    "image": ""
  },
  {
    "question": "在补码定点加法运算中，若采用一位符号位，则当( )时，表示结果溢出.",
    "options": [
      "A. 符号位产生进位",
      "B. 符号位进位和最高数位进位异或结果为0",
      "C. 符号位为1",
      "D. 符号位进位和最高数位进位异或结果为1"
    ],
    "chapter": "2.2整数表示和运算",
    "id": 14,
    "image": ""
  },
  {
    "question": "运算器中判断补码加减法运算结果是否溢出时，可采用判断进位的方式，在符号位的进位为C<sub>0</sub>，最高数值位进位为C<sub>1</sub>时，结果溢出的判定方法是( ).",
    "options": [
      "A. C<sub>0</sub>产生进位",
      "B. C<sub>1</sub>产生进位",
      "C. C<sub>0</sub>C<sub>1</sub>都同时产生进位",
      "D. C<sub>0</sub>C<sub>1</sub>中仅有一个产生进位"
    ],
    "chapter": "2.2整数表示和运算",
    "id": 15,
    "image": ""
  },
  {
    "question": "若采用双符号位补码运算，运算结果的符号位为01，更到( ).",
    "options": [
      "A. 产生了负溢出(下溢)",
      "B. 产生了正溢出(上溢)",
      "C. 结果正确，为正数",
      "D. 结果正确，为负数"
    ],
    "chapter": "2.2整数表示和运算",
    "id": 16,
    "image": ""
  },
  {
    "question": "机器运算发生溢出的根本原因是( ).",
    "options": [
      "A. 寄存器的位数有限",
      "B. 运算中将符号位的进位丢弃",
      "C. 运算中将符号位的借位丢弃",
      "D. 数据运算中发生错误"
    ],
    "chapter": "2.2整数表示和运算",
    "id": 17,
    "image": ""
  },
  {
    "question": "一个8位的二进制整数由2个“0“和6个“1“组成，采用补码或者移码表示，则下列说法中正确的是( ).",
    "options": [
      "A. 若采用移码表示，偏置值为127，则此整数最小为-64",
      "B. 若采用移码表示，偏置值为128，则此整数最大为123",
      "C. 若采用补码表示，则此整数最小为-96",
      "D. 若采用补码表示，则此整数最大为252"
    ],
    "chapter": "2.2整数表示和运算",
    "id": 18,
    "image": ""
  },
  {
    "question": "设[X]补=1x<sub>1</sub>x<sub>2</sub>x<sub>3</sub>x<sub>4</sub>x<sub>5</sub>x<sub>6</sub>，x<sub>i</sub>取0或1，若要x>-32，应该满足条件( ).",
    "options": [
      "A. x<sub>1</sub>为0，其他各位任意",
      "B. x<sub>1</sub>为1，x<sub>2</sub>x<sub>3</sub>x<sub>4</sub>x<sub>5</sub>x<sub>6</sub>中至少有一个为1",
      "C. x<sub>1</sub>为1，其他各位任意",
      "D. x1<sub>1</sub>为0，x<sub>2</sub>x<sub>3</sub>x<sub>4</sub>x<sub>5</sub>x<sub>6</sub>中至少有一个为1"
    ],
    "chapter": "2.2整数表示和运算",
    "id": 19,
    "image": ""
  },
  {
    "question": "【2010】假定有4个整数用8位补码分别表示：r<sub>1</sub>=FEH、r<sub>2</sub>=F2H、r<sub>3</sub>=90H、r<sub>4</sub>=F8H，若将运算结果存放在一个8位寄存器中，则下列运算发生溢出的是( ).",
    "options": [
      "A. r<sub>1</sub>×r<sub>2</sub>",
      "B. r<sub>2</sub>×r<sub>3</sub>",
      "C. r<sub>1</sub>×r<sub>4</sub>",
      "D. r<sub>2</sub>×r<sub>4</sub>"
    ],
    "chapter": "2.2整数表示和运算",
    "id": 23,
    "image": ""
  },
  {
    "question": "【2013】某字长为8位的计算机中，已知整型变量x、y的机器数分别为[x]<sub>补</sub>=111110100，[y]<sub>补</sub>=10110000.若整型变量z=2x+y/2，则z的机器数为( ).",
    "options": ["A. 110000000", "B. 00100100", "C. 10101010", "D. 溢出"],
    "chapter": "2.2整数表示和运算",
    "id": 24,
    "image": ""
  },
  {
    "question": "【2014】若x=103，y=-25，则下列表达来用8位定点补码运算时，会发生溢出的是( ).",
    "options": ["A. x+y", "B. -x+y", "C. x-y", "D. -x-y"],
    "chapter": "2.2整数表示和运算",
    "id": 25,
    "image": ""
  },
  {
    "question": "【2015】由3个“1“和5个“0“组成的8位二进制补码，能表示的最小整数是( ).",
    "options": ["A. -126", "B. -125", "C. -32", "D. -3"],
    "chapter": "2.2整数表示和运算",
    "id": 26,
    "image": ""
  },
  {
    "question": "【2018】假定有符号整数采用补码表示，若int型变量x和y的机器数分别是FFFFF FFDFH 100000041H，则x、y的值及x-y的机器数分别是( ).",
    "options": [
      "A. x=-65，y=41，x-y的机器数溢出",
      "B. x=-33，y=65，x-y的机器数为FFFF F9DH",
      "C. x=-33，y=65，x-y的机器数为FFFF FF9EH",
      "D. x=-65，y=41，x-y的机器数为FFFF FF96H"
    ],
    "chapter": "2.2整数表示和运算",
    "id": 27,
    "image": ""
  },
  {
    "question": "【2018】整数，的机器数为11000，分别对x进行遇罗辑右移1位和算术右移1位操作，得到的机器数各是( ).",
    "options": [
      "A. 1110 1100、1110 1100",
      "B. 0110 1100、1110 1100",
      "C. 1110 1100、0110 1100",
      "D. 0110 1100、0110 1100"
    ],
    "chapter": "2.2整数表示和运算",
    "id": 28,
    "image": ""
  },
  {
    "question": "【2021】已知带符号整数用补码表示，变量x，y，z的机器数分别为FFFDH，FFDFH，7FFCH，下列结论中，正确的是( ).",
    "options": [
      "A. 若x，y和z为无符号整数，则z<x<y",
      "B. 若x，y和z为无符号整数，则x<y<z",
      "C. 若x，y和z为带符号整数，则x<y<z",
      "D. 若x，y和z为带符号整数，则y<x<z"
    ],
    "chapter": "2.2整数表示和运算",
    "id": 29,
    "image": ""
  },
  {
    "question": "十进制数-9用IEEE754单精度浮点数表示为( ).",
    "options": ["A. 20000104H", "B. 82200001H", "C. 90000082H", "D. C1100000H"],
    "chapter": "2.3浮点数的表示和运算",
    "id": 1,
    "image": ""
  },
  {
    "question": "已知IEEE754单精度浮点数的十六进制值为42E48000，则它的十进制为( ).",
    "options": ["A. 114.25", "B. 57.125", "C. 50.25", "D. 28.5625"],
    "chapter": "2.3浮点数的表示和运算",
    "id": 2,
    "image": ""
  },
  {
    "question": "用IEE754格式表示的一个字为1 01111101 0010000000000000000000，这个字的十进制表示为( ).",
    "options": ["A. 0.03125", "B. -0.03125", "C. 0.28125", "D. -0.28125"],
    "chapter": "2.3浮点数的表示和运算",
    "id": 3,
    "image": ""
  },
  {
    "question": "采用规格化浮点数主要是为了( ).",
    "options": [
      "A. 增加浮点数的表示精度",
      "B. 加速浮点数的运算",
      "C. 增大浮点数的表示范围",
      "D. 防止运算时浮点数溢出"
    ],
    "chapter": "2.3浮点数的表示和运算",
    "id": 4,
    "image": ""
  },
  {
    "question": "下列关于IEEE754浮点数格式的叙述中，正确的是( ).",
    "options": [
      "A. 尾数和阶码均用原码表示",
      "B. 尾数用补码表示、阶码用原码表示",
      "C. 只能表示规格化数",
      "D. 可以表示规格化数和非规格化数"
    ],
    "chapter": "2.3浮点数的表示和运算",
    "id": 5,
    "image": ""
  },
  {
    "question": "已知float型变量采用IEEE 754单精度浮点标准表示.若x、y为float类型，且x=-126， y=15.75，则执行赋值语句z=x+y时，在浮点运算部件中进行对阶操作后的结果是( ).",
    "options": [
      "A. x不变，y为0 1000 0101，0.0011 1111 0···0",
      "B. x不变，y为0 1000 0110，0.0011 1111 0···0",
      "C. y不变，x为1 1000 0101，0.0011 1111 0···0",
      "D. y不变，x为1 1000 0110，0.0111 1111 0···0"
    ],
    "chapter": "2.3浮点数的表示和运算",
    "id": 6,
    "image": ""
  },
  {
    "question": "设某浮点数的阶码采用移码表示，尾数采用原码表示，判断该浮点数是否为规格化数的方法是( ).",
    "options": [
      "A. 尾数的最高位为1，其余位任意",
      "B. 尾数的最高位为0，其余位任意",
      "C. 尾数最高位和数符相同，其余位任意",
      "D. 尾数最高位和数符相异，其余位任意"
    ],
    "chapter": "2.3浮点数的表示和运算",
    "id": 7,
    "image": ""
  },
  {
    "question": "若浮点数尾数用补码表示，则判断运算结果是否为规格化数的方法是( ).",
    "options": [
      "A. 阶符与数符相同为规格化数",
      "B. 阶符与数符相异为规格化数",
      "C. 数符与尾数小数点后第一位数字相异为规格化数",
      "D. 数符与尾数小数点后第一位数字相同为规格化数"
    ],
    "chapter": "2.3浮点数的表示和运算",
    "id": 8,
    "image": ""
  },
  {
    "question": "浮点数加减运算中对阶的方法是( ).",
    "options": [
      "A. 将加数(减数)的阶码调整到和被加数(被减数)的阶码一致",
      "B. 将被加数(被减数)的阶码调整到和加数(减数)的价码一致",
      "C. 将两数中较小的阶码调整到和较大的阶码一致",
      "D. 将两数中较大的阶码调整到和较小的阶码一致"
    ],
    "chapter": "2.3浮点数的表示和运算",
    "id": 9,
    "image": ""
  },
  {
    "question": "对于IEEE754单精度浮点数加减运算，若运算结果直接取阶大的数，则两操作数的阶码之差大于等于( ).",
    "options": ["A. 24", "B. 25", "C. 126", "D. 128"],
    "chapter": "2.3浮点数的表示和运算",
    "id": 10,
    "image": ""
  },
  {
    "question": "十六进制表示的IEEE754标准32位单精度浮点数的规格化最大负数的机器数为( ).",
    "options": ["A. 80C00000H", "B. 80800000H", "C. 80000000H", "D. 80000001H"],
    "chapter": "2.3浮点数的表示和运算",
    "id": 11,
    "image": ""
  },
  {
    "question": "浮点数的表示范围和精度取决于( ).",
    "options": [
      "A. 阶码的位数和尾数的机器数形式",
      "B. 阶码的机器数形式和尾数的位数",
      "C. 阶码的位数和尾数的位数",
      "D. 阶码的机器数形式和尾数的机器数形式"
    ],
    "chapter": "2.3浮点数的表示和运算",
    "id": 12,
    "image": ""
  },
  {
    "question": "在IEEE754标准中，非规格化浮点数表示为( ).",
    "options": [
      "A. 阶码为0，尾数为任意非0二进制数",
      "B. 阶码为255，尾数为全0",
      "C. 阶码为255，尾数为任意非0二进制数",
      "D. 阶码为0，尾数为全0"
    ],
    "chapter": "2.3浮点数的表示和运算",
    "id": 13,
    "image": ""
  },
  {
    "question": "在规格化的浮点数中，将阶码部分的n位移码表示改为n位补码表示，其他不变，已知原来移码的偏置值为2“，则数的表示范围( ).",
    "options": ["A. 增大", "B. 减小", "C. 不变", "D. 都不对"],
    "chapter": "2.3浮点数的表示和运算",
    "id": 14,
    "image": ""
  },
  {
    "question": "某浮点数格式如下：7位阶码(包含一个符号位)，9位尾数(包含一个符号位).若阶码用移码表示、尾数用补码表示，则规格化浮点数所能表示数的为范围是( ).",
    "options": [
      "A. -2<sup>63</sup>~(1-2<sup>-8</sup>)×2<sup>63</sup>",
      "B. -2<sup>64</sup>~(1-2<sup>-7</sup>)×2<sup>64</sup>",
      "C. -(1-2<sup>-8</sup>)×2<sup>63</sup>~(1-2<sup>-8</sup>)×2<sup>63</sup>",
      "D. -(1-2<sup>-7</sup>)×2<sup>64</sup>~(1-2<sup>-8</sup>)×2<sup>63</sup>"
    ],
    "chapter": "2.3浮点数的表示和运算",
    "id": 15,
    "image": ""
  },
  {
    "question": "IEEE754标准规定的64位浮点数格式中，符号位为1位，阶码为11位，尾数为52位，则它所能表示的最小规格化负数为( ).",
    "options": [
      "A. -(2+2<sup>-52</sup>)×2<sup>-1023</sup>",
      "B. -(2-2<sup>-52</sup>)x2<sup>1023</sup>",
      "С. -1x2<sup>-1024</sup>",
      "D. -(1-2<sup>-52</sup>)×2<sup>2047</sup>"
    ],
    "chapter": "2.3浮点数的表示和运算",
    "id": 16,
    "image": ""
  },
  {
    "question": "C语言中，double类型变量所能表示的最接近0的规格化负数为( ).",
    "options": [
      "A. 2<sup>-1075</sup>-2<sup>-1024</sup>",
      "B. 2<sup>-1075</sup>-2<sup>-1023</sup>",
      "C. 2<sup>-1075</sup>-2<sup>-1022</sup>",
      "D. -2<sup>-1022</sup>"
    ],
    "chapter": "2.3浮点数的表示和运算",
    "id": 17,
    "image": ""
  },
  {
    "question": "字长相同但格式不同的两种浮点数，假设前者阶码长，尾数短，后者阶码短、尾数长，其他规定均相同，则它们可以表示的数的范围和精度为( ).",
    "options": [
      "A. 两者可表示的数的范围和精度相同",
      "B. 前者可表示的数的范围大但精度低",
      "C. 后者可表示的数的范围大且精度高",
      "D. 前者可表示的数的范围大且精度高"
    ],
    "chapter": "2.3浮点数的表示和运算",
    "id": 18,
    "image": ""
  },
  {
    "question": "【2009】浮点数加、减运算过程一般包括对阶、尾数运算、规格化、舍入和判断溢出等步骤.设浮点数的阶码和尾数均采用补码表示，且位数分别为5和7(均含2位符号位).若有两个数 X=2<sup>7</sup>×29/32和Y=2<sup>5</sup>×5/8，则用浮点加法计算X+Y的最终结果是( ).",
    "options": [
      "A. 00111 1100010",
      "B. 00111 0100010",
      "C. 01000 0010001",
      "D. 发生溢出"
    ],
    "chapter": "2.3浮点数的表示和运算",
    "id": 23,
    "image": ""
  },
  {
    "question": "【2011】float型数据通常用IEEE754单精度格式表示.若编译器将float型变量x分配在一个32位浮点寄存器FRI中，且x=-8.25.则FRI的内容是(し).",
    "options": [
      "A. C104 0000H",
      "B. C242 0000H",
      "C. С184 0000H",
      "D. C1C2 0000H"
    ],
    "chapter": "2.3浮点数的表示和运算",
    "id": 24,
    "image": ""
  },
  {
    "question": "【2012】float类型(即IEEE754单精度浮点数格式)能表示的最大正整数是( ).",
    "options": [
      "A. 2<sup>126</sup>-2<sup>104</sup>",
      "B. 2<sup>127</sup>-2<sup>104</sup>",
      "C. 2<sup>127</sup>-2<sup>103</sup>",
      "D. 2<sup>128</sup>-2<sup>104</sup>"
    ],
    "chapter": "2.3浮点数的表示和运算",
    "id": 25,
    "image": ""
  },
  {
    "question": "【2013】某数采用IEEE 754单精度浮点数格式表示为C6400000000000JH，则该数的值是( ).",
    "options": [
      "A. -1.5 × 2<sup>13</sup>",
      "D. -0.5 × 2<sup>12</sup>",
      "B. -1.5 × 2<sup>12</sup>",
      "С. -0.5 × 2<sup>13</sup>"
    ],
    "chapter": "2.3浮点数的表示和运算",
    "id": 26,
    "image": ""
  },
  {
    "question": "【2014】float型数据常用IEE 754单精度浮点格式表示.假设两个float型变量x和y分别存放在32位寄存器f1和f2中，若(f1)=CC90 0000H，(f2)=B0C0 0000H，则x和y之间的关系为 ( ).",
    "options": [
      "A. x<y且符号相同",
      "B. x<y且符号不同",
      "C. x>y且符号相同",
      "D. x>y且符号不同"
    ],
    "chapter": "2.3浮点数的表示和运算",
    "id": 27,
    "image": ""
  },
  {
    "question": "【2015】下列有关浮点数加减运算的叙述中正确的是( ).\nI.对阶操作不会引起阶码上溢或下溢\nII.右规和尾数舍入都可能引起阶码上溢\nIII.左规时可能引起阶码下溢\nIV.尾数溢出时结果不一定溢出",
    "options": [
      "A. 仅II、III",
      "B. 仅I、II、IV",
      "C. 仅I、III、IV",
      "D. I、II、III、IV"
    ],
    "chapter": "2.3浮点数的表示和运算",
    "id": 28,
    "image": ""
  },
  {
    "question": "【2018】IEEE754单精度浮点格式表示的数中，最小的规电格化正数是( ).",
    "options": [
      "A. 1.0×2<sup>-126</sup>",
      "B. 1.0×2<sup>-127</sup>",
      "С. 1.0×2<sup>-128</sup>",
      "D. 1.0×2<sup>-149</sup>"
    ],
    "chapter": "2.3浮点数的表示和运算",
    "id": 29,
    "image": ""
  },
  {
    "question": "【2020】已知带符号整数用补码表示，float型数据用IEEE7：54标准表示，假定变量x的类型只可能是int或float，当x的机器数为C800000000H时，x的值可能是( ).",
    "options": [
      "A. -7×2<sup>27</sup>",
      "B. -2<sup>16</sup>",
      "C. 2<sup>17</sup>",
      "D. 25×2<sup>27</sup>"
    ],
    "chapter": "2.3浮点数的表示和运算",
    "id": 30,
    "image": ""
  },
  {
    "question": "【2021】下列数值中，不能用IEE 754浮点格式精确表示乐的是( ).",
    "options": ["A. 1.2", "B. 1.25", "C. 2.0", "D. 2.5"],
    "chapter": "2.3浮点数的表示和运算",
    "id": 31,
    "image": ""
  },
  {
    "question": "有如下C语言程序段：\n\n<code>short si = -8196;\nunsigned short usi = si;</code>\n\n执行上述程序后，usi的值是( ).",
    "options": ["A. 8196", "B. 34572", "C. 57339", "D. 57340"],
    "chapter": "2.4 C语言中的类型转换",
    "id": 1,
    "image": ""
  },
  {
    "question": "有如下C语言程序段：\n\n<code>unsigned short usi = 62080;\nshort si = usi;</code>\n\n执行上述程序后，si的值是( ).",
    "options": ["A. 3456", "B. -3456", "C. 62080", "D. -62079"],
    "chapter": "2.4 C语言中的类型转换",
    "id": 2,
    "image": ""
  },
  {
    "question": "假定编译器规定int和short美型的长度为32位和16位，执行下列C语言语句后，x和y对应的机器数为( ) \n\n<code>unsigned short x = 32768;\nunsigned int y = x;</code>",
    "options": [
      "A. 8000H，FFFF8000H",
      "B. 7FFFH，00007FFFH",
      "C. 7FFFH，FFFF7FFFH",
      "D. 8000H，00008000H"
    ],
    "chapter": "2.4 C语言中的类型转换",
    "id": 3,
    "image": ""
  },
  {
    "question": "有如下C语言程序段：\n\n<code>unsigned char x = 254;\nunsigned short usi = x;</code>\n\n执行上述程序后，usi的机器数是( ).",
    "options": ["A. 007EH", "B. 00FEH", "C. FF7EH", "D. FFFFEH"],
    "chapter": "2.4 C语言中的类型转换",
    "id": 4,
    "image": ""
  },
  {
    "question": "有如下C语言程序段：\n\n<code>char si =120;\nunsigned char usi = si;</code>\n\n执行上述程序后，usi的值是( ).",
    "options": ["A. -120", "B. 120", "C. 135", "D. 136"],
    "chapter": "2.4 C语言中的类型转换",
    "id": 5,
    "image": ""
  },
  {
    "question": "有如下C语言程序段：\n\n<code>unsigned int usi = 4294967290;\nunsigned short tmp = usi;\nshort si = tmp;</code>\n\n已知4294967290=2<sup>32</sup>-6，执行上述程序后，si的值是( ).",
    "options": ["A. -5", "B. -6", "C. -2147483643", "D. -2147483642"],
    "chapter": "2.4 C语言中的类型转换",
    "id": 6,
    "image": ""
  },
  {
    "question": "有如下C语言程序段：\n\n<code>short si = -32768;\nunsigned short usi = si;\nint i = usi;</code>\n\n执行上述程序后，i的值是( ).",
    "options": ["A. -32767", "B. 32767", "-32768", "D. 32768"],
    "chapter": "2.4 C语言中的类型转换",
    "id": 7,
    "image": ""
  },
  {
    "question": "有如下C语言程序段：\n\n<code>unsigned short × = 0×FFF8001;\nunsigned int usi = x;</code>\n\n执行上迷程序后，×和usi的机器数分别是( ).",
    "options": [
      "A. 8001H，00008001H",
      "B. 8001H，FFFF8001H",
      "C. FFFFH，0000FFFFH",
      "D. FFFFH，FFFFFFFFH"
    ],
    "chapter": "2.4 C语言中的类型转换",
    "id": 8,
    "image": ""
  },
  {
    "question": "C语言int、short数据类型分别占用4字节和2字节，其程序在一台32位处理机上运行，程序中定义了三个变量a、b和y，其中a是int型，y和b为short型.当a=65537，b=-11时，执行语句y=a+b后，y的值为( ).",
    "options": ["A. 65526", "B. 31062", "С. -10", "D. -32756"],
    "chapter": "2.4 C语言中的类型转换",
    "id": 9,
    "image": ""
  },
  {
    "question": "在C语言中，long long类型变量表示的数值范围是( ).",
    "options": [
      "A. -2<sup>63</sup>~2<sup>63</sup>",
      "B. -2<sup>63</sup>~2<sup>63</sup>-1",
      "C. -2<sup>63</sup>+1~2<sup>63</sup>",
      "D. -2<sup>64</sup>~2<sup>64</sup>-1"
    ],
    "chapter": "2.4 C语言中的类型转换",
    "id": 10,
    "image": ""
  },
  {
    "question": "在32位机器上，某C语言程序中声明并初始化变量s的语句为“unsigned shorts=-5；“，若编译器将变量s分配到一个32位寄存器R中，则R的内容为( ).",
    "options": [
      "A. 0×00000005",
      "B. 0×FFFF0005",
      "C. 0×0000FFFB",
      "D. 0×FFFFFFFB"
    ],
    "chapter": "2.4 C语言中的类型转换",
    "id": 11,
    "image": ""
  },
  {
    "question": "一个C语言程序在32位概上链行，程序中定义了三个变量a、b、c，其中a为int型，b和c关成复习short型.当a=32785，b=17时，执行赋值语句c=a+b后，c的值为( ).",
    "options": ["A. -32768", "B. 0", "C. 32767", "D. 32768"],
    "chapter": "2.4 C语言中的类型转换",
    "id": 12,
    "image": ""
  },
  {
    "question": "下列关于C语言强制类型转换的说法中，正确的有( ).\nI.从int转换成float时，数据不会溢出，可能会舍入\nII.从float转换为int时，数据不会溢出，不会舍入\nIII.从float转换成double时，数据不会溢出，会舍入\nIV.从double转换成float时，数据可能会溢出，不会舍入",
    "options": ["A. 仅I", "B. 仅I、IV", "C. 仅I、III", "D. 仅II、III"],
    "chapter": "2.4 C语言中的类型转换",
    "id": 13,
    "image": ""
  },
  {
    "question": "在某C程序中，先将int型变量i初始化为-1056，然后对i进行算术右移8位操作.程序执行时i的值被保存在16位寄存器中，则移位操作结束后R中的内容是( ).",
    "options": ["A. 00FBH", "B. FFFBH", "C. 1F7CH", "D. FF7CH"],
    "chapter": "2.4 C语言中的类型转换",
    "id": 14,
    "image": ""
  },
  {
    "question": "一个C语言程序在32位机上运行，程序中定义了三个变量a、b、c，其中a为short型，b为int型，c为unsignedint型.当a=-64，b=32时，执行赋值语句c=a+b后，a、b、c的机器数分别( ).",
    "options": [
      "A. a=FF40H，b=00000020H，c=0000FFA0H",
      "B. a=FF40H，b=00000020H，c=FFFFFFAOH",
      "C. a=FFCOH，b=00000020H，c=0000FFE0H",
      "D. a=FFC0H，b=00000020H，c=FFFFFFE0H"
    ],
    "chapter": "2.4 C语言中的类型转换",
    "id": 15,
    "image": ""
  },
  {
    "question": "假定变量i、f和d的数据类型分别为int、float、double.已知i=16777217 (2<sup>24</sup>+1)， f=2.34567e4， d=3.14e150，则下列结果为真的是( ).",
    "options": [
      "A. i==(int)(float)i",
      "B. f==(float)(int)f",
      "C. f==(float)(double)f",
      "D. (d+f)-d==f"
    ],
    "chapter": "2.4 C语言中的类型转换",
    "id": 16,
    "image": ""
  },
  {
    "question": "变量i、f、d的数据类型分别是int、float、double类型.已知i=1、f=0.8、d=0.2，则结果为“假“的是( ).",
    "options": [
      "A. i==(int)(float)i",
      "B. i==(int)(float)(double)i",
      "C. f==(float)(double)f",
      "D. d==(double)(float)d"
    ],
    "chapter": "2.4 C语言中的类型转换",
    "id": 17,
    "image": ""
  },
  {
    "question": "假定变量i、f的数据类型分别是int、float.已知i=54321，f=5.4321e3，则在一个32位机器中执行下列表达时，结果为“假“的是( ).",
    "options": [
      "A. i==(int)(float)f",
      "B. f==(float)(int)i",
      "C. i==(int)(double)i",
      "D. f==(float)(double)f"
    ],
    "chapter": "2.4 C语言中的类型转换",
    "id": 18,
    "image": ""
  },
  {
    "question": "【2009】一个C语言程序在一台32位机器上运行.程序中定义了三个变量x、y、z，其中x和 z为int型，y为short型.当x=127、y=-9时，执行赋值语句z=x+y后，x、y之的值分别是( ).",
    "options": [
      "A. x=00000007FH，y=FFF9H，z=00000076H",
      "B. x=00000007FH，y=FFF9H，z=FFFF0076H",
      "С. x=00000007FH，y=FFF7H，z=FFFF0076H",
      "D. x=00000007FH，y=FFF7H，z=00000076H"
    ],
    "chapter": "2.4 C语言中的类型转换",
    "id": 20,
    "image": ""
  },
  {
    "question": "【2010】假定变量i、f和d的数据类型分别为int、float和double(int用补码表示，float和 double分别用IEEE754单精度和双精度浮点数格式表示)，已知i=785、f=1.5678e3、d=1.5e100，若在32位机器中执行下列关系表达式，则结果为“真“的是\n\nI.i=(int)(float)i\nII. f = (float)(int)f\nIII.f=(float)(double)f\nIV.f=(d+f)-d",
    "options": ["A. 仅I和II", "B. 仅I和III", "C. 仅II和III", "D. III和IV"],
    "chapter": "2.4 C语言中的类型转换",
    "id": 21,
    "image": ""
  },
  {
    "question": "【2012】假定编译器规定int和short类型长度分别1为32位和16位，执行下列C语言语句：\n<code>unsigned short x = 65530;\nunsigned int y = x;</code>\n得到y的机器数为( ).",
    "options": [
      "A. 0000 7FFAH",
      "B. 0000 FFFAH",
      "C. FFFF 7FFAH",
      "D. FFFF FFFAH"
    ],
    "chapter": "2.4 C语言中的类型转换",
    "id": 22,
    "image": ""
  },
  {
    "question": "【2016】有如下C语言程序段：\n\n<code>short si = =32767;\nunsigned short usi = si;</code>\n\n执行上述两条语句后，usi的值为( ).",
    "options": ["A. -32767", "B. 32767", "C. 32768", "D. 32769"],
    "chapter": "2.4 C语言中的类型转换",
    "id": 23,
    "image": ""
  },
  {
    "question": "【2019】考虑以下C语言代码，执行程序段后，si的值是( ).\n\n<code>unsigned short usi = 65535;\nshort si = usi;</code>",
    "options": ["A. -1", "B. -32767", "C. -32768", "D. -65535"],
    "chapter": "2.4 C语言中的类型转换",
    "id": 24,
    "image": ""
  },
  {
    "question": "运算器由多个部件组成，核心部件是( ).",
    "options": ["A. 累加寄存器", "B. ALU", "C. 数据总线", "D. Cache"],
    "chapter": "2.5 运算方法和运算电路",
    "id": 1,
    "image": ""
  },
  {
    "question": "算术逻辑部件ALU的核心部件是( ).",
    "options": ["A. 多路选择器", "B. 加法器", "C. 寄存器", "D. 移位器"],
    "chapter": "2.5 运算方法和运算电路",
    "id": 2,
    "image": ""
  },
  {
    "question": "数值数据和逻辑数据在形式上没有任何差别，计算机区别数值数据和逻辑数据的主要方法是",
    "options": [
      "A. 将数值数据和逻辑数据分开存放在不同的寄存器中",
      "B. 在数据中用专门的标识位指出是数值数据还是逻辑数据",
      "C. 用不同的指令操作码来区分本指令处理的是哪种数据",
      "D. 用不同的时间段来区分当时处理的是哪种数据"
    ],
    "chapter": "2.5 运算方法和运算电路",
    "id": 3,
    "image": ""
  },
  {
    "question": "关于计算机中的运算方法，以下说法正确的是",
    "options": [
      "A. 在补码加减运算中，[x-y]<sub>补</sub>=[x]<sub>补</sub>+[-y]<sub>补</sub>",
      "B. 在定点整数符号扩展中，需要扩展的位高位补0",
      "C. 在浮点加减运算中，对阶时常委将两个操作数中阶码较大的操作数的阶码调整到和阶码较小的操作数的阶码一致",
      "D. 算术右移的规则是：操作教的各位按住右移，最低位向右移出，最高位空住填“0“"
    ],
    "chapter": "2.5 运算方法和运算电路",
    "id": 4,
    "image": ""
  },
  {
    "question": "有关计算机中的数据运算，以下概念正确的是( ).\n\nI.定点和浮点运算的结果都可能发生溢出\nII.只有定点运算的结果才可能溢出，浮点运算的结果不可能溢出\nIII.在进行补码加法时，只有同号数据的运算才可能出现溢出\nIV.采用双符号位补码的定点加减运算不会发生溢出\nV.在进行补码乘法时，被乘数和乘数的符号均参与运算\nVI.在进行浮点除法运算时，需要判断被除数的尾数是否大于除数的尾数",
    "options": [
      "A. I、III、IV、V",
      "B. I、III、V、VI",
      "C. II、III、IV、V",
      "D. III、IV、V、VI"
    ],
    "chapter": "2.5 运算方法和运算电路",
    "id": 5,
    "image": ""
  },
  {
    "question": "在补码加/减运算部件中，必须有( )电路，它一般用异或门来实现.",
    "options": ["A. 译码", "B. 编码", "C. 溢出判断", "D. 移位"],
    "chapter": "2.5 运算方法和运算电路",
    "id": 6,
    "image": ""
  },
  {
    "question": "在定点二进制运算中，减法运算一般通过( )来实现",
    "options": [
      "A. 原码运算的十进制加法器",
      "B. 补码运算的二进制加法器",
      "C. 原码运算的二进制加法器",
      "D. 补码运算的二进制减法器"
    ],
    "chapter": "2.5 运算方法和运算电路",
    "id": 7,
    "image": ""
  },
  {
    "question": "下列说法正确的是( ).",
    "options": [
      "A. 定点运算的结果可能发生溢出，浮点运算的结果不可能发生溢出",
      "B. 定点运算的结果不可能发生溢出，浮点运算的结果可能发生溢出",
      "C. 定点运算的结果和浮点运算的结果都可能发生溢出",
      "D. 定点运算的结果和浮点运算的结果都不可能发生溢出"
    ],
    "chapter": "2.5 运算方法和运算电路",
    "id": 8,
    "image": ""
  },
  {
    "question": "下列说法正确的是( ).",
    "options": [
      "A. 采用变形补码进行加减运算可以避免溢出",
      "B. 只有定点数运算才有可能溢出，浮点数运算不会产生溢出",
      "C. 只有带符号数的运算才有可能产生溢出",
      "D. 将两个正数相加有可能产生溢出"
    ],
    "chapter": "2.5 运算方法和运算电路",
    "id": 8,
    "image": ""
  },
  {
    "question": "某CPU中，若进位/借位标志位CF、零标志位ZF、符号标志位SF(0表示正)、溢出标志为 OF，A、B为无符号整数，则判定A小于等于B的条件是( ).",
    "options": ["A. SF=1", "B. SF+ZF=1", "C. CF=1", "D. CF+ZF=1"],
    "chapter": "2.5 运算方法和运算电路",
    "id": 9,
    "image": ""
  },
  {
    "question": "加法器的输入包括两端操作数的输入和低位进位输入CCin.已知无符号数A=74、B=21.如果在8位加法器中计算A-B，那么加法器的两端输入和低位进位输入分别是( ).",
    "options": [
      "A. 01001010、00010101、0",
      "B. 01001010、00010101、1",
      "C. 01001010、11101010、1",
      "D. 01001010、11101011、0"
    ],
    "chapter": "2.5 运算方法和运算电路",
    "id": 10,
    "image": ""
  },
  {
    "question": "已知有符号数A=74、B=-21.如果在8位加法器中计十算A+B，那么加法器的两端输入和低位进位输入分别是( ).",
    "options": [
      "A. 01001010、00010101、0",
      "B. 01001010、00010101、1",
      "C. 01001010、11101010、1",
      "D. 01001010、11101011、0"
    ],
    "chapter": "2.5 运算方法和运算电路",
    "id": 11,
    "image": ""
  },
  {
    "question": "已知带符号整数A、B用补码表示，[A]<sub>补</sub>=BCH、[B]<sub>补</sub>=71H如果在8位加法器中计算A-B，那么加法器的低位进位输入Cin以及运算后溢出标志OF、最高位进位Cout、最高数值位进位分别是( ).",
    "options": [
      "A. 0、0、0、1",
      "B. 0、1、0、0",
      "C. 1、0、1、1",
      "D. 1、1、1、0"
    ],
    "chapter": "2.5 运算方法和运算电路",
    "id": 12,
    "image": ""
  },
  {
    "question": "已知无符号整数A、B的机器数分别是BCH、71H.如是果在8位加法器中计算A-B，那么加法器的低位进位输入Cin以及运算后进/借位标志CF、最高位进位Cout分别是( ).",
    "options": ["A. 1、0、1", "B. 0、1、1", "C. 1、1、1", "D. 0、0、0"],
    "chapter": "2.5 运算方法和运算电路",
    "id": 13,
    "image": ""
  },
  {
    "question": "采用Booth一位乘算法实现×·Y，则当乘数Y的最后两两位为10时，算法当前对部分积的操作为( ).",
    "options": [
      "A，右移1位",
      "B. +[x]<sub>补</sub>, 右移1位",
      "C. +[-×]<sub>补</sub>, 右移1位",
      "D. +[-×]<sub>补</sub>、左移1位"
    ],
    "chapter": "2.5 运算方法和运算电路",
    "id": 14,
    "image": ""
  },
  {
    "question": "【2011】装机器有一个标志寄存器，其中有进位/借位标志CF、零标志ZF、符号标志SF和溢出标志OF，条件转移指令bgt(无符号整数比较大于时转移)的转移条件是( ).",
    "options": [],
    "chapter": "2.5 运算方法和运算电路",
    "id": 18,
    "image": "/image/2_5_18.png"
  },
  {
    "question": "【2018】减法指令“subR1，R2，R3“的功能为“(R1)-(R2)-R3“，该指令执行后将生成进位/借位标志CF和溢出标志OF.若(R1)=FFFFFFFFFFFFFFFFFFFFFFFFFFFFFOH，则该减法指令执行后，CF 与OF分别为( ).",
    "options": [
      "A. CF=0， OF=0",
      "B. CF=1， OF=0",
      "C. CF=0， OF=1",
      "D. CF=1， OF=1"
    ],
    "chapter": "2.5 运算方法和运算电路",
    "id": 19,
    "image": ""
  },
  {
    "question": "下面存储器为永久性存储器的是",
    "options": [
      "A. DRAM和Cache",
      "B. SRAM和硬盘",
      "C. 优盘和Cache",
      "D. ROM和外存"
    ],
    "chapter": "3.1 存储器概述",
    "id": 1,
    "image": ""
  },
  {
    "question": "下面有关存储器的说法中，正确的是( ).",
    "options": [
      "A. SRAM是非易失性存储器，DRAM是易失性存储器",
      "B. 辅存是按顺序访问的存储器，主存一般是按随机存取方式访问的为存储器",
      "C. 辅存是非易失性存储器，主存是易失性存储器",
      "D. RAM和ROM都可用作Cache"
    ],
    "chapter": "3.1 存储器概述",
    "id": 2,
    "image": ""
  },
  {
    "question": "以下选项中，不正确的是( ).",
    "options": [
      "A. 随机存储器和只读存储器不可以统一编址",
      "B. 在访问随机存储器时，访问时间与存储单元的物理位置无关",
      "C. 随机存储器RAM芯片可随机存取信息，掉电后信息会丢失",
      "D. 只读存储器ROM芯片可随机存取信息，掉电后信息不会丢失"
    ],
    "chapter": "3.1 存储器概述",
    "id": 3,
    "image": ""
  },
  {
    "question": "关于存储器的分类，以下选项中正确的是( ).",
    "options": [
      "A. 为加快存取速度，Cache和TLB都可以采用相联储存器制成",
      "B. RAM是破坏性读取，ROM是非破坏性读取",
      "C. SRAM常用作Cache，DRAM常用作TLB",
      "D. 计算机的存储总容量=Cache容量+主存容量+辅存容量"
    ],
    "chapter": "3.1 存储器概述",
    "id": 4,
    "image": ""
  },
  {
    "question": "相联存储器是按( )进行寻址的存储器.",
    "options": [
      "A. 地址指定方式",
      "B. 堆栈指定方式",
      "C. 内容指定方式和堆栈存储方式相结合",
      "D. 内容指定方式和地址指定方式相结合"
    ],
    "chapter": "3.1 存储器概述",
    "id": 5,
    "image": ""
  },
  {
    "question": "设某台机器的存储容量为512MB，其机器字长为32位.若按字编址，则其可寻址的单元个数为( ).",
    "options": ["A. 64M", "B. 64MB", "C. 128M", "D. 128MB"],
    "chapter": "3.1 存储器概述",
    "id": 6,
    "image": ""
  },
  {
    "question": "连续两次启动同一存储器所需的最小时间间隔称为( ).",
    "options": ["A. 存取周期", "B. 存取时间", "C. 主存带宽", "D. 访问时间"],
    "chapter": "3.1 存储器概述",
    "id": 7,
    "image": ""
  },
  {
    "question": "某计算机字长16位，它的存储容量是128KB，若按字编址，那么它的寻址范围是( ).",
    "options": ["A. 64K", "B. 32K", "C. 64KB", "D. 32KB"],
    "chapter": "3.1 存储器概述",
    "id": 8,
    "image": ""
  },
  {
    "question": "对于下列代码，以下哪种改变使其具有更好的局部性( ).",
    "options": [
      "A. 将第2行与第3行互换",
      "B. 将第2行与第4行互换",
      "C. 将第5行改为：sum+=a[i][k][j]；",
      "D. 将第5行改为：sum+=a[j][i][k]"
    ],
    "chapter": "3.2 存储器层次结构",
    "id": 1,
    "image": "/image/3_2_1.png"
  },
  {
    "question": "关于这段代码中体现出的时间局部性和空间局部性.以下说法中正确的是( ).",
    "options": [
      "A. i和sum仅体现出时间局部性，arr仅体现出空间局部性",
      "B. 对于变量i和sum的访问体现出了较好的空间局部性",
      "C. 对于变量i、sum的访问体现出了较好的时间局部性，arr的访问体现出了较好的时间和空间局部性",
      "D. 对于变量i、sum和arr的访问体现出了较好的空间局部性"
    ],
    "chapter": "3.2 存储器层次结构",
    "id": 2,
    "image": "/image/3_2_2.png"
  },
  {
    "question": "以下哪种存储器与CPU没有直接数据通路( ).",
    "options": ["A. 内存", "B. Cache", "C. 硬盘", "D. 寄存器"],
    "chapter": "3.2 存储器层次结构",
    "id": 3,
    "image": ""
  },
  {
    "question": "层次化存储器结构的设计依据的原理是( ).",
    "options": [
      "A. 存储器周期性",
      "B. 存储器强制性",
      "C. 访存局部性",
      "D. 容量实效性"
    ],
    "chapter": "3.2 存储器层次结构",
    "id": 4,
    "image": ""
  },
  {
    "question": "CPU可直接由地址访问的存储器是( ).",
    "options": [
      "A. 虚拟存储器",
      "B. 磁盘存储器",
      "C. 磁带存储器",
      "D. 主存储器"
    ],
    "chapter": "3.2 存储器层次结构",
    "id": 5,
    "image": ""
  },
  {
    "question": "【2017】某C语言程序段如下，下列关于数组a的访问，局部性的描述中，正确的是( ).",
    "options": [
      "A. 时间局部性和空间局部性皆有",
      "B. 无时间局部性，有空间局部性",
      "C. 有时间局部性，无空间局部性",
      "D. 时间局部性和空间局部性皆无"
    ],
    "chapter": "3.2 存储器层次结构",
    "id": 7,
    "image": "/image/3_2_7.png"
  },
  {
    "question": "关于半导体存储器的组织，以下选项中不正确的是( ).",
    "options": [
      "A. 同一个存储器中，每个存储单元的宽度可以不同",
      "B. 所谓“编址“是指给每个存储单元一个编号",
      "C. 存储器的核心部分是存储阵列，由若干存储单元构成",
      "D. 每个存储单元由若干个存储元件构成，每个存储元件存放一个0或1的比特位"
    ],
    "chapter": "3.3 半导体随机存储器",
    "id": 1,
    "image": ""
  },
  {
    "question": "某1024K×32位的存储器由若干片128K×16位的SRAM芯片构成，每次读写4字节数据.若存储器按字节编址，则该存储器的地址线和数据线分别有( )条.",
    "options": ["A. 20，8", "B. 22，8", "C. 20，32", "D. 22，32"],
    "chapter": "3.3 半导体随机存储器",
    "id": 2,
    "image": ""
  },
  {
    "question": "关于SRAM和DRAM的特点，以下选项不正确的是( ).\n\nI.SRAM不需要刷新，而DRAM需要刷新，因此DRAM 的功耗更高\nII.DRAM比SRAM集成度更高，因此读写速度也更快\nIII.SRAM是易失性存储器，而DRAM是非易失性存储器\nIV.Cache由SRAM构成，主存由DRAM构成",
    "options": [
      "A. II III和IV",
      "B. I、III和IV",
      "C. I、II和III",
      "D. I、II、III和IV"
    ],
    "chapter": "3.3 半导体随机存储器",
    "id": 3,
    "image": ""
  },
  {
    "question": "DRAM具有破坏性读出的特性，需要定时刷新，因此被称为动态随机存储器.以下选项中不正确的是( ).",
    "options": [
      "A. 刷新是以行为单位的",
      "B. 刷新是为了给DRAM存储单元中的存储电容重新充电",
      "C. 刷新是通过对存储单元进行“读但不输出数据“，即“假读“的操作来实现的",
      "D. DRAM内部设有专门的刷新电路，不会影响到CPU的正常访存"
    ],
    "chapter": "3.3 半导体随机存储器",
    "id": 4,
    "image": ""
  },
  {
    "question": "对于某存储芯片，假定动态刷新闻隔为2ms，读写周期和刷新周期均为0.2μs，该芯片中包含128行，每个刷新周期可以完成1行存储单元的刷新，如果该芯片采用异步刷新方式工作，那么其读写周期和刷新周期可以安排为( ).",
    "options": [
      "A. 3999次读写周期后，安排一次刷新操作",
      "B. 2000次读写周期后，安排一次刷新操作",
      "C. 128次读写周期后，安排一次刷新操作",
      "D. 64次读写周期后，安排一次刷新操作"
    ],
    "chapter": "3.3 半导体随机存储器",
    "id": 5,
    "image": ""
  },
  {
    "question": "关于RAM和ROM芯片，以下选项不正确的是( ).",
    "options": [
      "A. ROM和RAM都采用随机访问方式进行读写",
      "B. RAM是可读可写存储器，ROM是只读存储器",
      "C. 系统的主存由RAM和ROM组成",
      "D. 系统的主存都用DRAM芯片实现"
    ],
    "chapter": "3.3 半导体随机存储器",
    "id": 6,
    "image": ""
  },
  {
    "question": "关于半导体存储器的特点，以下选项不正确的是( ).",
    "options": [
      "A. ROM芯片采用随机存取方式进行读写",
      "B. ROM芯片属于半导体随机存储器芯片",
      "C. SRAM是半导体静态随机访问存储器，可用作Cache和TLB",
      "D. DRAM是半导体动态随机访问存储器，可用作主存"
    ],
    "chapter": "3.3 半导体随机存储器",
    "id": 7,
    "image": ""
  },
  {
    "question": "下列存储芯片无法多次写入信息的是( ).",
    "options": ["A. RAM", "B. MROM", "C. FLASH", "D. EEPROM"],
    "chapter": "3.3 半导体随机存储器",
    "id": 8,
    "image": ""
  },
  {
    "question": "以下对半导体存储器的叙述正确的是( ).",
    "options": [
      "A. Flash存储器功耗低，集成度高，读写速度一样快，目前得到了广泛使用",
      "B. SRAM是易失性半导体存储器，需要刷新，用作Cache",
      "C. DRAM集成度高、功耗低，用作主存",
      "D. EEPROM是一种需要通过紫外线擦除的存储器"
    ],
    "chapter": "3.3 半导体随机存储器",
    "id": 9,
    "image": ""
  },
  {
    "question": "下列关于存储器的叙述正确的是\n\nI.动态存储器是利用电容电荷来存储信息的，需要周期性逐个刷新每一个存储单元\nII.FLASH具有不易失特性，所以它是ROM且无法更新存储单元\nIII.DRAM是动态存储器，采用随机存取方式，存取地址需分两次送入",
    "options": ["A. I", "B. I、II", "C. II、III", "D. III"],
    "chapter": "3.3 半导体随机存储器",
    "id": 10,
    "image": ""
  },
  {
    "question": "SRAM芯片的引脚类型有电源线、接地端、地址线、数据线、片选线和读写控制线.求除去电源和接地端外，一个容量为16K×8位的SRAM芯片的引脚数量最少为( )条.",
    "options": ["A. 22", "B. 23", "C. 24", "D. 25"],
    "chapter": "3.3 半导体随机存储器",
    "id": 11,
    "image": ""
  },
  {
    "question": "存储容量为16K×4位的DRAM芯片，其地址引脚和数据引脚数各是",
    "options": ["A. 7，1", "B. 7，4", "C. 14，1", "D. 14，4"],
    "chapter": "3.3 半导体随机存储器",
    "id": 12,
    "image": ""
  },
  {
    "question": "【2010】下列有关RAM和ROM的叙述中，正确的是( ).\n\nI.RAM是易失性存储器，ROM是非易失性存储器\nII.RAM和ROM都采用随机存取方式进行信息访问\nIII.RAM和ROM都可用作Cache\nIV.RAM和ROM都需要进行刷新",
    "options": [
      "A. 仅I和II",
      "B. 仅II和III",
      "C. 仅I、II和IV",
      "D. 仅II、III和IV"
    ],
    "chapter": "3.3 半导体随机存储器",
    "id": 14,
    "image": ""
  },
  {
    "question": "【2011】下列各类存储器中，不采用随机存取方式的是( ).",
    "options": ["A. EPROM", "B. CD-ROM", "C. DRAM", "D. SRAM"],
    "chapter": "3.3 半导体随机存储器",
    "id": 15,
    "image": ""
  },
  {
    "question": "【2012】下列关于闪存(FlashMemory)的叙述中，错误的是( ).",
    "options": [
      "A. 信息可读可写，并且读、写速度一样快",
      "B. 存储元由MOS管组成，是一种半导体存储器",
      "C. 掉电后信息不丢失，是一种非易失性存储器",
      "D. 采用随机访问方式，可替代计算机外部存储器"
    ],
    "chapter": "3.3 半导体随机存储器",
    "id": 16,
    "image": ""
  },
  {
    "question": "【2014】某容量为256MB的存储器由若干4M×8位的DRAM芯片构成，该DRAM芯片的地址引脚和数据引脚总数是( ).",
    "options": ["A. 19", "B. 22", "C. 30", "D. 36"],
    "chapter": "3.3 半导体随机存储器",
    "id": 17,
    "image": ""
  },
  {
    "question": "【2015】下列存储器中，在工作期间需要周期性刷新的是( ).",
    "options": ["A. SRAM", "B. SDRAM", "C. ROM", "D. FLASH"],
    "chapter": "3.3 半导体随机存储器",
    "id": 18,
    "image": ""
  },
  {
    "question": "【2018】假定DRAM芯片中存储阵列的行数为r、列数为c，对于一个2K×1位的DRAM芯片， 为保证其地址引脚数最少，并尽量减少刷新开销，则r、c的取值分别是( ).",
    "options": ["A. 2048、1", "B. 64、32", "C. 32、64", "D. 1、2048"],
    "chapter": "3.3 半导体随机存储器",
    "id": 19,
    "image": ""
  },
  {
    "question": "某计算机的主存容量大小为128KB. \n\n(1)若按字节编址，则MAR和MDR的位数分别是( ).\n(2)若按字编址，1字=2字节，则MAR和MDR的位数分别是( ).",
    "options": [
      "A. 17，8，16，16",
      "B. 16，16，16，16",
      "C. 16，8，17，8",
      "D. 17，16，16， 8"
    ],
    "chapter": "3.4 主存储器",
    "id": 1,
    "image": ""
  },
  {
    "question": "已知计算机主存由RAM和ROM共同构成，两者统一编址. 某计算机的物理地址为20位，按字节编址，ROM区的地址为00000H~0BFFFH，其余空间均使用8K×8位的RAM芯片填充，则需要( )个这样的RAM芯片.",
    "options": ["A. 61", "B. 62", "C. 122", "D. 123"],
    "chapter": "3.4 主存储器",
    "id": 2,
    "image": ""
  },
  {
    "question": "假设某CPU上的地址引脚数为24，数据引脚数为32.若用256K×16位的RAM芯片组成该机的主存储器，则最多需要( )片这样的存储芯片.",
    "options": ["A. 64", "B. 128", "C. 256", "D. 512"],
    "chapter": "3.4 主存储器",
    "id": 3,
    "image": ""
  },
  {
    "question": "若内存地址A000H~B7FFH的区间用6块RAM构成，已矣知存储字长为16位且按字编址，则可以使用的RAM芯片规格为( ).",
    "options": ["A. 512×32位", "B. 2048×16位", "C. 2048×8位", "D. 512×16位"],
    "chapter": "3.4 主存储器",
    "id": 4,
    "image": ""
  },
  {
    "question": "假设某32K×32位的存储器由若干4K×8位的芯片组成，以地址总线的高位作为片选，则加在各存储芯片上的片选线是( ).",
    "options": ["A. A14~A0", "B. A11~A0", "C. A14~A12", "D. A14~A11"],
    "chapter": "3.4 主存储器",
    "id": 5,
    "image": ""
  },
  {
    "question": "假设一个64K×8位的存储器，由若干个8K×8位的存储芯芯片组成.则地址BA3DH所在芯片的最小地址为( ).",
    "options": ["A. A000H", "B. B000H", "C. 0000H", "D. 000DH"],
    "chapter": "3.4 主存储器",
    "id": 6,
    "image": ""
  },
  {
    "question": "当片选信号为110的时候，存储器内的一个8K×8位的存储芯片被选定，则该芯片在存储器中的首末地址为( ).",
    "options": [
      "A. D000H，DFFFH",
      "B. 0000H，1FFFH",
      "C. C000H，DFFFH",
      "D. 0000H，FFFFH"
    ],
    "chapter": "3.4 主存储器",
    "id": 7,
    "image": ""
  },
  {
    "question": "某容量为128KB的存储器由若干8K×8位的芯片抗展而成，若其存储字长为16位且内存按字编址，则地址BC2FH所在芯片的首地址为( ).",
    "options": ["A. 8000H", "B. B000H", "C. A000H", "D. F000H"],
    "chapter": "3.4 主存储器",
    "id": 8,
    "image": ""
  },
  {
    "question": "一个容量为128KB的SRAM芯片按字长32位编址，其地址范围可从0000H到( ).",
    "options": ["A. 3FFFH", "B. 7FFFH", "C. 7FFFFH", "D. 3FFFFH"],
    "chapter": "3.4 主存储器",
    "id": 9,
    "image": ""
  },
  {
    "question": "关于单体多字存储器，以下选项中不正确的是( ).",
    "options": [
      "A. 单体多字存储器主要解决主存容量太小的问题",
      "B. 单体多字存储器中，每个存储单元存储多个字",
      "C. 指令与数据的连续存放有利于单体多字存储器提高主存的读写速度",
      "D. 过多的跳转指令会严重影响单体多字存储器的工作效率"
    ],
    "chapter": "3.4 主存储器",
    "id": 10,
    "image": ""
  },
  {
    "question": "关于存储系统，以下选项中正确的是( ).",
    "options": [
      "A. 信息按边界存储的含义是存储单元的地址必须是整数",
      "B. 单体多字存储器是交叉编址的多模块存储器",
      "C. 在交叉编址的多模块存储器中、当连续的n次访存操作作用于不同的存储体时、该存储器的存取带宽是单体存储器的n倍",
      "D. 可以采用增加Cache容量的方法提高存储系统的存储容量"
    ],
    "chapter": "3.4 主存储器",
    "id": 11,
    "image": ""
  },
  {
    "question": "关于多模块存储器，以下选项中正确的是( ).",
    "options": [
      "A. 高位交叉存储器有效的利用了程序的局部性原理",
      "B. 多体并行存储器里拥有多个模块，每个模块都有自己的读写控制电路",
      "C. 高位交叉存储器是连续编址的多模块存储器，无法提高存取效率",
      "D. 低位n体交叉存储器的存取效率一定是单体存储器的n倍"
    ],
    "chapter": "3.4 主存储器",
    "id": 12,
    "image": ""
  },
  {
    "question": "某低位交叉存储器有4个模块，存储周期为200ns，存储字长为16位，按字编址，其每个体的容量是64K×16位.若总线传输周期为50ns，该存储器读取的平均速度为( ).",
    "options": [
      "A. 2×10<sup>8</sup>bit/s",
      "B. 3.2×10<sup>8</sup>bit/s",
      "C. 2×10<sup>7</sup>bit/s",
      "D. 3.2×10<sup>7</sup>bit/s"
    ],
    "chapter": "3.4 主存储器",
    "id": 13,
    "image": ""
  },
  {
    "question": "一个八体低位交叉存储器，每个存储体的容量为256Mx64位，若每个体的存储周期为80ns，那么该存储器能提供的最大带宽是( ).",
    "options": ["A. 426.67MB/S", "B. 800MB/S", "C. 213.33MB/S", "D. 400MB/S"],
    "chapter": "3.4 主存储器",
    "id": 14,
    "image": ""
  },
  {
    "question": "采用四体并行低住交叉存储器.没每个体的存储客量为32Kx16位，存取周期为400ms，在下述说法中( )是正确的.",
    "options": [
      "A. 在0.1µs内，存储器可向CPU提供64位二进制信息",
      "B. 在0.1µs内，每个体可向CPU提供16位二进制信息",
      "C. 在0.4µs内，存储器可向CPU提供64位二进制信息",
      "D. 在0.4µs内，每个体可向CPU提供32位二进制信息"
    ],
    "chapter": "3.4 主存储器",
    "id": 15,
    "image": ""
  },
  {
    "question": "下列有关存储器的描述中，正确答案是( ).",
    "options": [
      "A. Cache的功能由硬件实现",
      "B. 访问存储器的请求是由CPU发出的",
      "C. Cache与主存统一编址，即主存空间的某一部分属于Cache",
      "D. 多体交叉存储主要解决扩充容量的问题"
    ],
    "chapter": "3.4 主存储器",
    "id": 16,
    "image": ""
  },
  {
    "question": "【2009】某计算机主存容量为64KB，其中ROM区为4KB，其余为RAM区，按字节编址.现要用2K×8位的ROM芯片和4Kx4位的RAM芯片来设计该存储器，则需要上述规格的ROM芯片数和RAM芯片数分别是( ).",
    "options": ["A. 1，15", "B. 2，15", "C. 1，30", "D. 2，30"],
    "chapter": "3.4 主存储器",
    "id": 22,
    "image": ""
  },
  {
    "question": "【2010】假定用若干2Kx4位的芯片组成一个8Kx8位的存储器，则地址0B1FH所在芯片的最小地址是( ).",
    "options": ["A. 0000H", "B. 0600H", "C. 0700H", "D. 0800H"],
    "chapter": "3.4 主存储器",
    "id": 23,
    "image": ""
  },
  {
    "question": "【2011】某计算机存储器按字节编址，主存地址空间间大小为64MB，现用4M×8位的RAM芯片组成32MB的主存储器，则存储器地址寄存器MAR的位数至主少是( ).",
    "options": ["A. 22位", "B. 23位", "C. 25位", "D. 26位"],
    "chapter": "3.4 主存储器",
    "id": 24,
    "image": ""
  },
  {
    "question": "【2015】某计算机使用4体交叉编址存储器，假定存储器总线上出现的主存地址(十进制)序列为8005，8006，8007，8008，8001，8002，8003，8004，8000，可能发生访存冲突的地址对是( ).",
    "options": [
      "A. 8004和8008",
      "B. 8002和8007",
      "C. 8001和8008",
      "D. 8000和8004"
    ],
    "chapter": "3.4 主存储器",
    "id": 25,
    "image": ""
  },
  {
    "question": "【2016】某存储器容量为64KB，按字节编址，地址4000H~5FFFH为ROM区，其余为RAM区.若采用8K×4位的SRAM芯片进行设计，则需要该芯片的数量是( ).",
    "options": ["A. 7", "B. 8", "C. 14", "D. 16"],
    "chapter": "3.4 主存储器",
    "id": 26,
    "image": ""
  },
  {
    "question": "【2017】某计算机主存按字节编址，由4个64M×8位的DRAM芯片采用交叉编址方式构成，并与宽度为32位的存储器总线相连，主存每次最多读写32位数据.若double型变量x的主存地址为804 001AH，则读取x需要的存储周期是( ).",
    "options": ["A. 1", "B. 2", "C. 3", "D. 4"],
    "chapter": "3.4 主存储器",
    "id": 27,
    "image": ""
  },
  {
    "question": "【2021】某计算机的存储器总线中有24位地址线和32位数据线，按字编址，字长为32位.如果00 0000H~3F FFFFH为RAM区，那么需要512K×8位的RAM芯片数为( ).",
    "options": ["A. 8", "B. 16", "C. 32", "D. 64"],
    "chapter": "3.4 主存储器",
    "id": 28,
    "image": ""
  },
  {
    "question": "磁盘转速提高一倍，则( ).",
    "options": [
      "A. 寻道时间缩小一半",
      "B. 存取速度也提高一倍",
      "C. 平均查找时间缩小一倍",
      "D. 不影响磁盘传输速率"
    ],
    "chapter": "3.5 外存储器",
    "id": 1,
    "image": ""
  },
  {
    "question": "下列选项中，可以提高磁盘的存储容量的是( ).",
    "options": [
      "A. 加快磁盘转速",
      "B. 提高磁头移动速度",
      "C. 增加磁盘Cache",
      "D. 增加位密度"
    ],
    "chapter": "3.5 外存储器",
    "id": 2,
    "image": ""
  },
  {
    "question": "已知硬盘的传输速率为10MB/s，磁盘转速为9600RPM，磁盘控制器延时1.5ms，平均寻道时间为10.5ms，则该硬盘写2KB数据的时间为( ).",
    "options": ["A. 13.825ms", "B. 15.125ms", "C. 15.325ms", "D. 18.45ms"],
    "chapter": "3.5 外存储器",
    "id": 3,
    "image": ""
  },
  {
    "question": "假设装磁盘具有16个盘片和8192个柱面，每磁道有512个扇区，每个扇区有512字节，则该磁盘的总容量为( ).",
    "options": ["A. 32MB", "B. 32GB", "C. 16MB", "D. 16GB"],
    "chapter": "3.5 外存储器",
    "id": 4,
    "image": ""
  },
  {
    "question": "假设某磁盘的每磁道有512个扇区，每个扇区有512字节.已知该磁盘转速为9600RPM，则其最大数据传输率为( ).",
    "options": ["A. 2400MB/s", "B. 9600KB/s", "C. 40MB/s", "D. 256KB/s"],
    "chapter": "3.5 外存储器",
    "id": 5,
    "image": ""
  },
  {
    "question": "以下选项不正确的是( ).",
    "options": [
      "A. RAID通过冗余技术提高磁盘的磁记录密度和磁盘利用率",
      "B. 硬盘和U盘格式化后容量会变小",
      "C. U盘和SSD都是基于闪存的存储技术，都属于只读存储.器",
      "D. 计算磁盘的存取时间时，“寻道时间“和“旋转等待时1间“的计算通常取其平均值"
    ],
    "chapter": "3.5 外存储器",
    "id": 6,
    "image": ""
  },
  {
    "question": "假定某一磁盘的转速为6000RPM(转/分)，平均寻道时间为5ms，平均数据传输率为4MB/s， 不考虑排队时间.那么读一个512B扇区的平均时间大约为( ).",
    "options": ["A. 5.125ms", "B. 10.125ms", "C. 15.125ms", "D. 20.125ms"],
    "chapter": "3.5 外存储器",
    "id": 7,
    "image": ""
  },
  {
    "question": "下列磁盘阵列模式中，没有容错功能的是( ).",
    "options": ["A. RAID0", "B. RAID1", "C. RAID3", "D. RAID5"],
    "chapter": "3.5 外存储器",
    "id": 8,
    "image": ""
  },
  {
    "question": "下面关于RAID(Redundant Array of Inexpensive Disks)的说法中错误的是( ).",
    "options": [
      "A. RAID0没有容错能力，但其提高了磁盘的访问速度",
      "B. RAID1实现了磁盘镜像，磁盘的利用率降低了一半",
      "C. RAID3采用字节拨别的奇偶校验实现容错，奇偶校验位交叉分布在阵列中的各个磁食中",
      "D. RAID5采用区块级别的奇偶校验实现容错，奇偶校验位交叉分布在阵列中的各个磁盘中"
    ],
    "chapter": "3.5 外存储器",
    "id": 9,
    "image": ""
  },
  {
    "question": "以下正确的叙述是( ).",
    "options": [
      "A. RAID0采用镜像盘",
      "B. RAID1无冗余",
      "C. RAID2采用CRC校验",
      "D. RAID3采用奇偶校验"
    ],
    "chapter": "3.5 外存储器",
    "id": 10,
    "image": ""
  },
  {
    "question": "关于SSD的特点，以下说法不正确的是( ).",
    "options": [
      "A. 读写速度较快，常用作主存",
      "B. 读写性能明显高于磁盘",
      "C. 基于闪存的存储技术",
      "D. 写入次数有限，需要考虑磨损"
    ],
    "chapter": "3.5 外存储器",
    "id": 11,
    "image": ""
  },
  {
    "question": "关于SSD的特点，以下说法不正确的是( ).",
    "options": [
      "A. 固态硬盘的读写是以页为单位的",
      "B. 固态硬盘的擦除是以页为单位的",
      "C. 由于固态硬盘在写入时需要擦除，所以固态硬盘的写入比读取要慢很多",
      "D. 由于固态硬盘的写入次数有限，为延长使用寿命，一般引入磨损均衡"
    ],
    "chapter": "3.5 外存储器",
    "id": 12,
    "image": ""
  },
  {
    "question": "【2013】某磁盘的转速为10000转/分，平均寻道时间是6ms，磁盘传输速率是20MB/s，磁盘控制器延迟为0.2ms，读取一个4KB的扇区所需的平均时间约为为( ).",
    "options": ["A. 9ms", "B. 9.4ms", "C. 12ms", "D. 12.4ms"],
    "chapter": "3.5 外存储器",
    "id": 15,
    "image": ""
  },
  {
    "question": "【2013】下列选项中，用于提高RAID可靠性的措施有( ).\nI.磁盘镜像 II.条带化 III.奇偶校验 IV.增加Cache机制",
    "options": [
      "A. 仅I、II",
      "B. 仅I、III",
      "C. 仅I、II、IV",
      "D. 仅II、III、IV"
    ],
    "chapter": "3.5 外存储器",
    "id": 16,
    "image": ""
  },
  {
    "question": "【2015】若磁盘转速为7200转/分，平均寻道时间为8ms每个磁道包含1000个扇区，则访问一个扇区的平均存取时间大约是( ).",
    "options": ["A. 8.1ms", "B. 12.2ms", "C. 16.3ms", "D. 20.5ms"],
    "chapter": "3.5 外存储器",
    "id": 17,
    "image": ""
  },
  {
    "question": "【2019】下列关于磁盘存储器的叙述中，错误的是( ).",
    "options": [
      "A. 磁盘的格式化容量比非格式化容量小",
      "B. 扇区中包含数据、地址和校验等信息",
      "C. 磁盘存储器的最小读写单位为一个字节",
      "D. 磁盘存储器由磁盘控制器、磁盘驱动器和盘片组成"
    ],
    "chapter": "3.5 外存储器",
    "id": 18,
    "image": ""
  },
  {
    "question": "下列对Cache的表述中，通常是正确的是( ).\n\nI.指令Cache往比数据Cache具备更强的空间局部性\nII.由于空间局部性，增加Cache块大小通常会导致更高的命中率\nIII.写回Cache的写操作少于写直达Cache",
    "options": ["A. III", "B. I、II", "C. II、III", "D. I、II和III"],
    "chapter": "3.6 Cache",
    "id": 1,
    "image": ""
  },
  {
    "question": "下面关于计算机Cache的论述中，正确的是( ).",
    "options": [
      "A. Cache位于主辅存之间，缓存辅存数据",
      "B. Cache替换时的单位为字节",
      "C. 无论何时，Cache中的信息一定与主存中的信息一致",
      "D. Cache的命中率必须很高，一般要达到90%以上"
    ],
    "chapter": "3.6 Cache",
    "id": 2,
    "image": ""
  },
  {
    "question": "下列场景下，Cache的作用发挥较好的是( ).",
    "options": [
      "A. 不含有过多的中断操作",
      "B. 访问的数据大多在外存中",
      "C. 有大量循环语句和数组顺序访问",
      "D. 各指令相关度不高"
    ],
    "chapter": "3.6 Cache",
    "id": 3,
    "image": ""
  },
  {
    "question": "设CPU发送指令和数据地址到存储器需1个时钟周期，存储器收到CPU信息到传出数据需7个时钟周期，总线上每传送1次数据需1个时钟周期.若Cache块大小为32B，存取宽度和总线宽度都为4B，则读一次Cache块至少要( )个时钟周期.",
    "options": ["A. 40", "B. 64", "C. 72", "D. 160"],
    "chapter": "3.6 Cache",
    "id": 4,
    "image": ""
  },
  {
    "question": "Cache采用全相联映射方式，共16行，能存放8MB的数据，主存容量为128MB. Cache的读写时间为5ns，主存读写时间为100ns，平均访问时间为6ns，则Cache的命中率为( ).",
    "options": ["A. 99%", "B. 98%", "C. 97%", "D. 96%"],
    "chapter": "3.6 Cache",
    "id": 5,
    "image": ""
  },
  {
    "question": "在CPU执行一段程序的过程中，共访存1000次，其中Cache命中950次.设Cache存取周期为10ns，主存存取周期为120ns，则Cache-主存系统的效率是( ).",
    "options": ["A. 62%", "B. 62.5%", "C. 90%", "D. 90.5%"],
    "chapter": "3.6 Cache",
    "id": 6,
    "image": ""
  },
  {
    "question": "假设Cache的读写速度是主存的10倍，命中率为90%，则何使用Cache能使存储器的读写速度提高( )倍.",
    "options": ["A. 9", "B. 10", "C. 1.19", "D. 5"],
    "chapter": "3.6 Cache",
    "id": 7,
    "image": ""
  },
  {
    "question": "Cache的存储时间是50ns，主存的存储时间是800ns，若平均访问时间不超过70ns，则Cache的命中率至少为( ).",
    "options": ["A. 99%", "B. 97.5%", "C. 95.5%", "D. 90%"],
    "chapter": "3.6 Cache",
    "id": 8,
    "image": ""
  },
  {
    "question": "以下方法中对于提高Cache命中率没有效果的是( ).",
    "options": [
      "A. 增加Cache容量",
      "B. 增加主存容量",
      "C. 对程序优化编译",
      "D. 采用合适的地址映像方式"
    ],
    "chapter": "3.6 Cache",
    "id": 9,
    "image": ""
  },
  {
    "question": "台计算机有两级Cache，在访问中依次通过两级Cache，某程序存在执行过程中访存1000次， 其中访问第1级Cache时有40次不命中，接着再通过第2级Cache，仍然有10次不命中，则总命中率是( ).",
    "options": ["A. 99%", "B. 90%", "C. 96%", "D. 75%"],
    "chapter": "3.6 Cache",
    "id": 10,
    "image": ""
  },
  {
    "question": "某计算机主存地址32位，按字节编址，采用二级Cache，L1为数据Cache，L2为指令Cache 主存块大小64B，Cache与主存为直接映射方式，采用写回法和随机替换策略，每个Cache都有64行，两个Cache大小与映射方式均相同. 此二级Cache的容量至少有( ).",
    "options": ["A. 8512B", "B. 8544B", "C. 8512bit", "D. 8544bit"],
    "chapter": "3.6 Cache",
    "id": 11,
    "image": ""
  },
  {
    "question": "某计算机主存地址32位，按字节编址，Cache与主存为全相联B块射方式.主存块大小为4B，采用写回法(Write Back)和随机替换策略，则能存放64KB数据的Cache的总容量至少有( )位.",
    "options": ["A. 512K", "B. 1024K", "C. 2048K", "D. 64K"],
    "chapter": "3.6 Cache",
    "id": 12,
    "image": ""
  },
  {
    "question": "Cache采用8路组相联映射方式，共有64块.若主存有16K块，按字节编址，主存块大小为256B，则Cache标记的位数为( ).",
    "options": ["A. 7", "B. 8", "C. 10", "D. 11"],
    "chapter": "3.6 Cache",
    "id": 13,
    "image": ""
  },
  {
    "question": "在同一个Cache里，有3种缺新方式可以采用，总体上发生冲突概率最小的是( ).",
    "options": ["A. 直接映射", "B. 全相联映射", "C. 组相联映射", "D. 都一样"],
    "chapter": "3.6 Cache",
    "id": 14,
    "image": ""
  },
  {
    "question": "若主存按字节编址，主存块大小为32B，Cache共有64行，主存和Cache间采用直接映射方式， 编号都从0开始.则主存第2123号单元(十进制)对应的Cache行号是( ).",
    "options": ["A. 0", "B. 1", "C. 2", "D. 3"],
    "chapter": "3.6 Cache",
    "id": 15,
    "image": ""
  },
  {
    "question": "某计算机Cache容量为1KB，采用4路组相联映射方式，主存容量为1MB，每个主存块大小为32字节，按字节编址.若CPU访问主存地址819A7H单元且Cache命中，则该单元位于Cache 组号是( ).",
    "options": ["A. 2", "B. 5", "C. 10", "D. 13"],
    "chapter": "3.6 Cache",
    "id": 16,
    "image": ""
  },
  {
    "question": "假设在一个Cache中共有M块，每K块组成一个组，那么以下叙述正确的是( ).",
    "options": [
      "A. 如果K=1，则该Cache是直接映射Cache",
      "B. 如果K=1，则该Cache是全相联映射Cache",
      "C. 如果K=M，则该Cache是直接映射Cache",
      "D. 如果K>1且K<M，那么这是M/K路的组相联映射Cache"
    ],
    "chapter": "3.6 Cache",
    "id": 17,
    "image": ""
  },
  {
    "question": "一个八路组相联Cache共有64块，主存共有8192块，每块64个字节，那么主存地址的标记x、组号y和块内地址2分别是( ).",
    "options": [
      "A. x=4，y=3，z=6",
      "B. x=1，y=6，z=6",
      "C. x=10，y=3，z=6",
      "D. x=7，y=6，z=6"
    ],
    "chapter": "3.6 Cache",
    "id": 18,
    "image": ""
  },
  {
    "question": "命中率高且电路实现简单的Cache与内存映射方式的是( ).",
    "options": ["A. 全相联映射", "B. 直接映射", "C. 组相联映射", "D. 哈希映射"],
    "chapter": "3.6 Cache",
    "id": 19,
    "image": ""
  },
  {
    "question": "保持Cache块大小和数量不变的前提下，将Cache相联度提高一倍，可能会发生的是( ).\nI.减少Cache访问时间\nII.增加Cache块偏移量需要的位数\nIII.减少索引需要的位数",
    "options": ["A. I", "B. III", "C. I、II", "D. II、III"],
    "chapter": "3.6 Cache",
    "id": 20,
    "image": ""
  },
  {
    "question": "组相联映射和全相联映射通常适合于( ).",
    "options": [
      "A. 小容量Cache",
      "B. 大容量Cache",
      "C. 小容量ROM",
      "D. 大容量ROM"
    ],
    "chapter": "3.6 Cache",
    "id": 21,
    "image": ""
  },
  {
    "question": "假设有一个块数为4的Cache，采取全相联映射.起初Cache中内容为空，接下来CPU连续访问了以下主存块(均为十进制)：1，2，3，4，5，4，2，3，5，1.当Cache采取LRU替换策略时，命中率为( ).",
    "options": ["A. 20%", "B. 30%", "C. 40%", "D. 50%"],
    "chapter": "3.6 Cache",
    "id": 22,
    "image": ""
  },
  {
    "question": "在不同情况下，需要采用适合的Cache写策略.(1)主要运行访问密集型应用，其中包含写操作.(2)安全性要求很高，不允许有任何数据不一致的情况发生.这两种情况中，更适合的写策略分别是( ).",
    "options": [
      "A. 写回法，全写法",
      "B. 全写法，写回法",
      "C. 写回法，写回法",
      "D. 全写法，全写法"
    ],
    "chapter": "3.6 Cache",
    "id": 23,
    "image": ""
  },
  {
    "question": "关于Cache的全写法(写直达法)和写回法这两种写策略，以下说法正确的是\nI.采用写回法时，只有在第一次写入Cache时需要写入主存\nII.采用全写法时，写命中时则同时写Cache和辅存\nIII.采用写回法时，每块Cache都需要多加一位辅助位",
    "options": ["A. 仅I、III", "B. 仅II", "C. 仅III", "D. I、II和III"],
    "chapter": "3.6 Cache",
    "id": 24,
    "image": ""
  },
  {
    "question": "写直达法可以有效地保持主存和Cache一致性，但是写操作将花费大量的时间，这个问题的种解决方法是( ).",
    "options": [
      "A. 采用写回机制",
      "B. 采用写缓冲",
      "C. 采用victim Cache",
      "D. 采用组相联映射"
    ],
    "chapter": "3.6 Cache",
    "id": 25,
    "image": ""
  },
  {
    "question": "【2009】某计算机的Cache共有16块，采用2路组相联映射方式(即每组2块).每个主存块大小为32B，按字节编址.主存129号单元所在主存块应装入到的Cache组号是( ).",
    "options": ["A. 0", "B. 1", "C. 4", "D. 6"],
    "chapter": "3.6 Cache",
    "id": 32,
    "image": ""
  },
  {
    "question": "【2009】假设某计算机的存储系统由Cache和主存组成，某程序执行过程中访存1000次，其中访问Cache缺失(未命中)50次，则Cache的命中率是( ).",
    "options": ["A. 5%", "B. 9.5%", "C. 50%", "D. 95%"],
    "chapter": "3.6 Cache",
    "id": 33,
    "image": ""
  },
  {
    "question": "【2012】假设某计算机按字编址，Cache有4个行，Cache和3主存之间交换的块大小为1个字.若Cache的内容初始为空，采用2路组相联映射方式和LRU替换策略.访问的主存地址依次为 0，4，8，2，0，6，8，6，4，8时，命中Cache的次数是C).",
    "options": ["A. 1", "B. 2", "C. 3", "D. 4"],
    "chapter": "3.6 Cache",
    "id": 34,
    "image": ""
  },
  {
    "question": "【2014】采用指令Cache与数据Cache分离的主要目的是( ).",
    "options": [
      "A. 降低Cache的缺失损失",
      "B. 提高Cache的命中率",
      "C. 降低CPU平均访存时间",
      "D. 减少指令流水线资源冲突"
    ],
    "chapter": "3.6 Cache",
    "id": 35,
    "image": ""
  },
  {
    "question": "【2015】假定主存地址为32位，按字节编址，主存和Cache之间采用直接映射方式，主存块大小为4个字，每字32位，采用回写(Write Back)方式，则分能存放4K字数据的Cache的总容量的位数至少是( ).",
    "options": ["A. 146K", "B. 147K", "C. 148K", "D. 158K"],
    "chapter": "3.6 Cache",
    "id": 36,
    "image": ""
  },
  {
    "question": "【2016】有如下C语言程序段，若数组a及变量k均为int型，int型数据占4B，数据Cache采用直接映射方式、数据区大小为1KB、块大小为16B，该相星序段执行前Cache为空，则该程序段执行过程中访问数组a的Cache缺失率约为( ).<code>for (k = 0； k < 1000； k++)\n    a[k] = a[k] + 32;</code>",
    "options": ["A. 1.25%", "B. 2.5%", "C. 12.5%", "D. 25%"],
    "chapter": "3.6 Cache",
    "id": 37,
    "image": ""
  },
  {
    "question": "【2021】若计算机主存地址为32位，按字节编址，Cache数据区大小为32KB，主存块大小为 32B，采用直接映射方式和回写(Write Back)策略，则Cache行的位数至少是( ).",
    "options": ["A. 275", "B. 274", "C. 258", "D. 257"],
    "chapter": "3.6 Cache",
    "id": 38,
    "image": ""
  },
  {
    "question": "下述有关虚拟存储器的说法中错误的是( ).",
    "options": [
      "A. 虚拟存储器的目的是为了给每个用户提供独立的、比较大的编程空间",
      "B. 根据虚拟地址访存时，至少要访问两次主存",
      "C. 用户在虚拟存储器系统中的编程空间一般都大于实际空间",
      "D. 虚拟存储器对应用程序员是透明的"
    ],
    "chapter": "3.7 虚拟存储器",
    "id": 1,
    "image": ""
  },
  {
    "question": "下述有关Cache与虚拟存储器的说法中错误有( ).\nI.一次访存时，页表不命中，则Cache一定也不命中\nII.Cache不命中的损失要大于页表不命中的损失\nIII.Cache和TLB缺失后的处理都是由硬件完成\nIV.虚拟存储器的容量可以大于主存和辅存的容量之和",
    "options": ["A. I和IV", "B. III和IV", "C. II和IV", "D. I、II和IV"],
    "chapter": "3.7 虚拟存储器",
    "id": 2,
    "image": ""
  },
  {
    "question": "下列说法中，错误的是( ).\nI.虚拟存储器的容量不能超过虚拟地址的表示范围\nII.虚拟存储器加快了计算机的访存速度\nIII.缺页处理发生在存储器的主存与辅存层次之间\nIV.虚拟地址的长度一般小于物理地址的长度",
    "options": ["A. 仅II", "B. I和II", "C. III 和 IV", "D. II和IV"],
    "chapter": "3.7 虚拟存储器",
    "id": 3,
    "image": ""
  },
  {
    "question": "采用虚拟存储器的主要目的是( ).",
    "options": [
      "A. 提高主存存取速度",
      "B. 提高外存存取速度",
      "C. 扩大主存使用空间",
      "D. 扩大主存存储空间"
    ],
    "chapter": "3.7 虚拟存储器",
    "id": 4,
    "image": ""
  },
  {
    "question": "下列有关页式虚拟存储器的说法中正确的是( ).",
    "options": [
      "A. 页面的大小由程序的逻辑结构所决定",
      "B. 所有页面的大小都是相同的",
      "C. 可以把一些常用的页表项放入Cache中",
      "D. 程序运行前要将其全部放入主存中"
    ],
    "chapter": "3.7 虚拟存储器",
    "id": 5,
    "image": ""
  },
  {
    "question": "某页式虚拟存储系统的虚拟地址为32位，按字节编址，一页的大小为4KB，每个页表项为64 位，则该页表的总容量为( ).",
    "options": ["A. 4KB", "B. 8KB", "C. 4MB", "D. 8MB"],
    "chapter": "3.7 虚拟存储器",
    "id": 6,
    "image": ""
  },
  {
    "question": "以下是有关TLB的叙述，其中错误的是( ).",
    "options": [
      "A. TLB由SRAM构成",
      "B. TLB存放的是当前进程的常用页表项",
      "C. TLB命中时，Cache也一定命中",
      "D. TLB称为快表，页表称为慢表"
    ],
    "chapter": "3.7 虚拟存储器",
    "id": 7,
    "image": ""
  },
  {
    "question": "下列关于Cache与TLB的描述中，说法正确的是( ).",
    "options": [
      "A. TLB存放的是主存信息的副本",
      "B. Cache存放的是页表内容的副本",
      "C. 一次访存过程中，访问Cache的时间早于访问TIB的时间",
      "D. TLB和Cache都加快了访存速度"
    ],
    "chapter": "3.7 虚拟存储器",
    "id": 8,
    "image": ""
  },
  {
    "question": "下列命中组合情况中，一次访存过程中不可能发生的力是( ).",
    "options": [
      "A. TLB未命中，Cache未命中，Page命中",
      "B. TLB未命中，Cache命中，Page命中",
      "C. TLB未命中，Cache未命中，Page未命中",
      "D. TLB未命中，CCache命中，Page未命中"
    ],
    "chapter": "3.7 虚拟存储器",
    "id": 9,
    "image": ""
  },
  {
    "question": "在主存地址空间大小为16MB的计算机中，虚拟地址空间大小为256MB，采用页式存储管理， 按字节编址.若页面大小为64KB，TLB采用全相联映射，其内容如下所示.则虚拟地址0BACC63H的页框号是( ).",
    "options": ["A. 1AH", "B. 06H", "C. TLB缺失", "D. 缺页"],
    "chapter": "3.7 虚拟存储器",
    "id": 10,
    "image": "/image/3_7_10.png"
  },
  {
    "question": "假定页表有一个控制位C，用来表示对应页面是否可在Cache缓存.C=l表示可在Cache缓存， C=0表示不可在Cache缓存.以下关于虚实地址转换时对C进行相关处理的描述，其中错误的是( ).",
    "options": [
      "A. 若装入位为0，则无需考虑C的取值如何",
      "B. 若修改位为1，则不管C原来的值如何都将其清0",
      "C. 若C=0，则根据转换后的地址直接访问主存而不访问Cache",
      "D. 若C=1，则根据转换后的地址先到Cache中进行访问"
    ],
    "chapter": "3.7 虚拟存储器",
    "id": 11,
    "image": ""
  },
  {
    "question": "TLB，Page，Cache这三项的缺失(Miss)、命中(Hit)组合中可以存在的为( ).",
    "options": [
      "A. TLB命中，Page缺失，Cache缺失",
      "B. TLB命中，Page命命中，Cache缺失",
      "C. TLB命中，Page缺失，Cache命中",
      "D. TLB缺失，Page缺失，Cache命中"
    ],
    "chapter": "3.7 虚拟存储器",
    "id": 12,
    "image": ""
  },
  {
    "question": "以下虚拟存储器中，以页为单位与主存交换信息的是( ).\nI.页式虚拟存储器\nII.段式虚拟存储器\nIII.段页式虚拟存储器",
    "options": ["A. 仅I", "B. 仅III", "C. 仅I，III", "D. I， II， III"],
    "chapter": "3.7 虚拟存储器",
    "id": 13,
    "image": ""
  },
  {
    "question": "【2010】下列命中组合情况中，一次访存过程中不可能发生的是( ).",
    "options": [
      "A. TLB未命中，Cache未命中，Page未命中",
      "B. TLB未命中，Cache命中，Page命中",
      "C. TLB命中，Cache未命中，Page命中",
      "D. TLB命中，Cache命中，Page未命中"
    ],
    "chapter": "3.7 虚拟存储器",
    "id": 18,
    "image": ""
  },
  {
    "question": "【2013】某计算机主存地址空间大小为256MB，按字节编址.虚拟地址空间大小为4GB，采用页式存储管理，页面大小为4KB，TLB(快表)采用全相联映射，有4个页表项，内容如下表所示.则对虚拟地址03FFF180H进行虚实地址变换的结果是).",
    "options": ["A. 015 3180H", "B. 003 5180H", "C. TLB缺失", "D. 缺页"],
    "chapter": "3.7 虚拟存储器",
    "id": 19,
    "image": "/image/3_7_19.png"
  },
  {
    "question": "【2015】假定编译器将语句“x=x+3；“转换为指令“add xaddr，3“，其中，xaddr是x对应的存储单元地址.若执行该指令的计算机采用页式虚拟存储管理方式，并配有相应的TLB，且Cache 使用直写(Write Through)方式，则完成该指令功能需要访问主存的次数至少是( ).",
    "options": ["A. 0", "B. 1", "C. 2", "D. 3"],
    "chapter": "3.7 虚拟存储器",
    "id": 20,
    "image": ""
  },
  {
    "question": "【2019】下列关于缺页处理的叙述中，错误的是( ).",
    "options": [
      "A. 缺页是在地址转换时CPU检测到的一种异常",
      "B. 缺页处理由操作系统提供的缺页处理程序来完成",
      "C. 缺页处理程序根据页故障地址从外存读入所缺失的页",
      "D. 缺页处理完成后回到发生缺页的指令的下一条指令执行"
    ],
    "chapter": "3.7 虚拟存储器",
    "id": 21,
    "image": ""
  },
  {
    "question": "【2020】下列关于TLB和Cache的叙述中，错误的是( ).",
    "options": [
      "A. 命中率都与程序局部性有关",
      "B. 缺失后都需要去访问主存",
      "C. 缺失处理都可以由硬件实现",
      "D. 都由DRAM存储器组成"
    ],
    "chapter": "3.7 虚拟存储器",
    "id": 22,
    "image": ""
  },
  {
    "question": "关于指令格式，下列说法错误的是( ).",
    "options": [
      "A. 一条指令通常是由操作码和地址码构成，其中地址码有时可省略",
      "B. 为了充分利用存储器空间，指令的长度通常是字节的整数倍",
      "C. 一地址指令是固定长度的指令",
      "D. 单字长指令可加快取指令的速度"
    ],
    "chapter": "4.2 指令格式",
    "id": 1,
    "image": ""
  },
  {
    "question": "下列三种类型的指令(R表示寄存器，S表示主存)，执行速度最快的是( ).",
    "options": ["A. RR型", "B. RS型", "C. SS型", "D. 不确定"],
    "chapter": "4.2 指令格式",
    "id": 2,
    "image": ""
  },
  {
    "question": "下列关于指令字长、机器字长和存储字长的说法正确的是美( ).\nI.机器字长一定和指令字长相等\nII.机器字长一定和存储字长相等\nIII.指令字长和机器字长没有必然的联系\nIV.指令字长反映了计算机的运算精度，即字长起长，寻址范围越大，精度越高",
    "options": ["A. I、III", "B. III", "C. III、IV", "D. 没有正确选项"],
    "chapter": "4.2 指令格式",
    "id": 3,
    "image": ""
  },
  {
    "question": "程序控制类指令的功能是( ).",
    "options": [
      "A. 进行主存和CPU之间的数据传送",
      "B. 进行CPU和设备之间的数据传送",
      "C. 改变程序执行的顺序",
      "D. 使PC自动+1"
    ],
    "chapter": "4.2 指令格式",
    "id": 4,
    "image": ""
  },
  {
    "question": "双操作数的零地址运算指令在指令格式中不给出操作数，它的操作数来自( ).",
    "options": [
      "A. 立即数和栈顶",
      "B. 暂存器",
      "C. 暂存器和通用寄存器",
      "D. 栈顶和次栈顶"
    ],
    "chapter": "4.2 指令格式",
    "id": 5,
    "image": ""
  },
  {
    "question": "一个计算机系统采用32位单字长指令，地址码为12位，如果定义了249条二地址指令，那么一地址指令最多有( )条.",
    "options": ["A. 16K", "B. 32K", "C. 28K", "D. 24K"],
    "chapter": "4.2 指令格式",
    "id": 6,
    "image": ""
  },
  {
    "question": "运算型指令的寻址和转移型指令的寻址不同点是( ) .",
    "options": [
      "A. 前者是定长指令格式，后者是变长指令格式",
      "B. 前者是长指令，后者是短指令",
      "C. 前者是短指令，后者是长指令",
      "D. 前者取操作数，后者决定程序转移地址"
    ],
    "chapter": "4.2 指令格式",
    "id": 7,
    "image": ""
  },
  {
    "question": "下列有关标志寄存器的叙述中，错误的是( ).",
    "options": [
      "A. 主要用于反映处理器的状态和ALU运算结果的某些特征",
      "B. 不需要对标志寄存器进行编号",
      "C. 可通过指令直接访问标志寄存器并修改其值",
      "D. 条件转移指令需要根据标志寄存器的值确定PC的值"
    ],
    "chapter": "4.2 指令格式",
    "id": 8,
    "image": ""
  },
  {
    "question": "在指令格式中，采用扩展操作码设计的目的是( ).",
    "options": [
      "A. 减少指令长度",
      "B. 增加指令长度",
      "C. 保持指令长度不变而增加操作指令的数量",
      "D. 保持指令长度不变而增加寻址空间"
    ],
    "chapter": "4.2 指令格式",
    "id": 9,
    "image": ""
  },
  {
    "question": "指令操作码采用变长编码，两地址指令有12条，使用频度80%；一地址指令有10条，使用频度20%，则一地址指令的操作码最短应为( )位.",
    "options": ["A. 3", "B. 4", "C. 5", "D. 6"],
    "chapter": "4.2 指令格式",
    "id": 10,
    "image": ""
  },
  {
    "question": "指令的长度为16位，每个地址码5位，现采用操作码扩展技术，若二地址指令为60条、零地址指令为256条，则一地址最多有( ).",
    "options": ["A. 120条", "B. 128条", "C. 64条", "D. 512条"],
    "chapter": "4.2 指令格式",
    "id": 11,
    "image": ""
  },
  {
    "question": "设某机器的指令字长为16位，每个地址码段长为4位，用广展操作码方法设计指令格式.若该指令系统中已定义了12条三地址指令，62条二地址指令，30条一地址指令，则该指令系统最多可以有( )条零地址指令.",
    "options": ["A. 2", "B. 16", "C. 32", "D. 64"],
    "chapter": "4.2 指令格式",
    "id": 12,
    "image": ""
  },
  {
    "question": "假设某计算机采用小端方式存储，按字节编址.某数组起始地址为1500H，有10个int类型元素(大小为4字节)，则数组第9个元素的最高有效字节(MSE3)所在的地址应为",
    "options": ["A. 1520H", "B. 1523H", "C. 1524H", "D. 1527H"],
    "chapter": "4.3 数据的对齐和大/小端存放方式",
    "id": 1,
    "image": ""
  },
  {
    "question": "设机器数字长16位，C语言程序段如下，其中CPU为大端方式，则执行完程序片段后m的高位字节内容为\n\n<code>    int n = 0xA1B6;\n    unsigned int m n;\n    m = m>>1;</code>",
    "options": ["A. 50H", "B. A1H", "С. В6H", "D. DBH"],
    "chapter": "4.3 数据的对齐和大/小端存放方式",
    "id": 2,
    "image": ""
  },
  {
    "question": "假设计算机采用大端方式存储，按字节编址，若一维数组a有100个元素，其类型为double， 存放在地址0C00 1000H开始的连续区域中，则最后一个元素组元素LSB(最低有效字节)所在的地址为",
    "options": [
      "A. 0C00 1792H",
      "B. 0C00 1799H",
      "C. 0C00 1318H",
      "D. 0C00 131FH"
    ],
    "chapter": "4.3 数据的对齐和大/小端存放方式",
    "id": 3,
    "image": ""
  },
  {
    "question": "【2018】假设某32位计算机按字节编址，采用小端(Little Endian)方式.若语句“inti=0；“对应指令的机器代码为“C7 45 FC 00 00 00 00“，则语句“int i = -64；“对应指令的机器代码是",
    "options": [
      "A. C7 45 FC C0 FF FF FF",
      "B. C7 45 FC OC FF FF FF",
      "C. C7 45 FC FF FF FF C0",
      "D. C7 45 FC FF FF FF 0C"
    ],
    "chapter": "4.3 数据的对齐和大/小端存放方式",
    "id": 4,
    "image": ""
  },
  {
    "question": "【2020】在按字节编址，采用小端方式的32位计算机中，接安边界对齐方式为以下C语言结构型变量a分配存储空间，若a的首地址为2020 FE00H，a的成员变量x2的机器数为1234 0000H，则其中34H所在的存储单元的地址是\n<code>struct record{\n    short xi；\n    int x2；\n} a；</code>",
    "options": [
      "A. 2020 FE03H",
      "B. 2020 FE04H",
      "C. 2020 FE05H",
      "D. 2020 FE06H"
    ],
    "chapter": "4.3 数据的对齐和大/小端存放方式",
    "id": 5,
    "image": ""
  },
  {
    "question": "指令系统中采用不同的寻址方式的主要目的是( )",
    "options": [
      "A. 简化指令的译码，提升译码速度",
      "B. 提升指令的访存速度",
      "C. 保持指令系统的稳定性",
      "D. 缩短指令字长，扩大寻址空间，提高编程灵活性"
    ],
    "chapter": "4.4 指令寻址和数据寻址",
    "id": 1,
    "image": ""
  },
  {
    "question": "如果指令中地址码所给出的是操作数的有效地址，则该指令使用的寻址方式是( )",
    "options": ["A. 直接寻址", "B. 立即寻址", "C. 寄存器寻址", "D. 间接寻址"],
    "chapter": "4.4 指令寻址和数据寻址",
    "id": 2,
    "image": ""
  },
  {
    "question": "固定指令字长的情况下，在数据寻址的各种方式中，获取取操作数最快的方式",
    "options": ["A. 直接寻址", "B. 立即寻址", "C. 寄存器寻址", "D. 间接寻址"],
    "chapter": "4.4 指令寻址和数据寻址",
    "id": 3,
    "image": ""
  },
  {
    "question": "如果一次间接寻址的范围是224，多次间接寻址需要额外借助不存储字的最高位作为标志位判断寻址是否结束，那么三次间接寻址的寻址范围是( )",
    "options": [
      "A. 2<sup>24</sup>",
      "B. 2<sup>25</sup>",
      "C. 2<sup>23</sup>",
      "D. 2<sup>22</sup>"
    ],
    "chapter": "4.4 指令寻址和数据寻址",
    "id": 4,
    "image": ""
  },
  {
    "question": "为了使指令中地址码的位数相对较短，同时使指令的执行时间尽可能短，应使用的寻址方式是",
    "options": [
      "A. 立即寻址",
      "B. 寄存器寻址",
      "C. 直接寻址",
      "D. 寄存器间接寻址"
    ],
    "chapter": "4.4 指令寻址和数据寻址",
    "id": 5,
    "image": ""
  },
  {
    "question": "假设某机器有7个通用寄存器，某指令的一个操作数采用)用基址寻址的寻址方式，采用通用寄存器作为基址寄存器，指令中的寄存器的编号为002H，寄存器002H中的值为2022H，地址2022H 中的内容为B111H，指令中给出的形式地址为2023H，地址2023H中的内容是2048H，那么该操作数的有效地址为( )",
    "options": ["A. D159H", "B. 2025H", "C. 4045H", "D. D134H"],
    "chapter": "4.4 指令寻址和数据寻址",
    "id": 6,
    "image": ""
  },
  {
    "question": "假设某指令的一个操作教采用变址寻址的寻址方式，变址寄存器中的值为1000H，地址1000H 中的内容为0002H，指令中给出的形式地址为2022H，地地址2022H中的内容是2048H，那么该操作数的有效地址为( ).",
    "options": ["A. 2050H", "B. 3022H", "C. 3048H", "D. 204AH"],
    "chapter": "4.4 指令寻址和数据寻址",
    "id": 7,
    "image": ""
  },
  {
    "question": "设某主机主存地址与存储单元之间对应关系如下：现某指令的操作数寻址方式采用相对寻址，其形式地址部分的内容A=1000H，寄存器(PC)= 2000H，该指令执行时读取的操作数是( )",
    "options": ["A. 1000H", "B. 2000H", "C. 3000H", "D. 6000H"],
    "chapter": "4.4 指令寻址和数据寻址",
    "id": 8,
    "image": "/image/4_4_8.png"
  },
  {
    "question": "某指令系统，指令字长为两个字节，某转移指令采用相对寻址的寻址方式，其中第一个字节为操作码，第二个字节为偏移量(补码表示)，每当CPU从存储器取出一个字节时，会完成 (PC)+1→PC的操作.若当前指令地址为2000H，要求传移到2023H和若当前指令地址为 2023H，要求转移到2010H，则该转指令的第二个字节的内容分别为( )",
    "options": ["A. 23H F1H", "B. 21H F3H", "C. 23H F3H", "D. 21H F1H"],
    "chapter": "4.4 指令寻址和数据寻址",
    "id": 9,
    "image": ""
  },
  {
    "question": "关于数据寻址，下列说法错误的是( )",
    "options": [
      "A. 直接寻址的寻址范围取决于形式地址的位数",
      "B. 寄存器直接寻址不需要访问主存，因此是速度最快的寻去址方式",
      "C. 变址寻址常用于解决数组的问题",
      "D. 相对寻址常用于跳转指令"
    ],
    "chapter": "4.4 指令寻址和数据寻址",
    "id": 10,
    "image": ""
  },
  {
    "question": "某指令使用堆栈寻址的方式，设A是累加器、SP为堆栈指示器，M40为SP指示的栈顶单元如果入栈的操作是(SP)+1->SP，(A)->M<sub>sp</sub>，那么出钱的动作应为( )",
    "options": [
      "A. (SP)+1->SP，(MS<sub>sp</sub>)->A",
      "B. (M<sub>sp</sub>)->A，(SP)+1->SP",
      "C. (SP)-1->SP，(MS<sub>sp</sub>)->A",
      "D. (MS<sub>sp</sub>)->A，(SP)-1->SP"
    ],
    "chapter": "4.4 指令寻址和数据寻址",
    "id": 11,
    "image": ""
  },
  {
    "question": "设相对寻址的转移指令为32位，前两个字节为操作码，第三、四个字节为相对偏移量(补码形式表示).每当CPU从存储器取出一个字节时，会完成(PC)+1->PC的操作.若PC的当前值为2024H，指令执行后PC转移到2000H，则转移指令的第三、四字节的机器代码是( )",
    "options": ["A. 2000H", "B. 2024H", "C. 0024H", "D. FFD8H"],
    "chapter": "4.4 指令寻址和数据寻址",
    "id": 12,
    "image": ""
  },
  {
    "question": "设变址寄存器为IX，形式地址为A，某计算机具有先变址再间址一次的寻址方式，则这种寻址方式的有效地址EA的计算式为( )",
    "options": [
      "A. EA=(IX)+A",
      "B. EA=(IX)+(A)",
      "C. EA=((IX)+A)",
      "D. EA=((IX)+(A))"
    ],
    "chapter": "4.4 指令寻址和数据寻址",
    "id": 13,
    "image": ""
  },
  {
    "question": "设相对寻址的转移指令占用2个字节，前4位是操作码为，后12位是相对位移量(补码表示)， 则该转移指令可转移的地址范围是( ).",
    "options": ["A. 4095", "B. 4096", "C. 63", "D. 64"],
    "chapter": "4.4 指令寻址和数据寻址",
    "id": 14,
    "image": ""
  },
  {
    "question": "寄存器R1、R2均为16位，指令MOV RI，[R2]的功能是把内存数据传送至R1寄存器，寻址方式为寄存器间接寻址.R2的值为1234H，1234H处内存单元存放数据56H(按字节编址)，内存1235H的单元存放数据78H，数据存储采用小端方式.执行指令后R1值为( ).",
    "options": ["A. 5678H", "B. 7856H", "C. 8765H", "D. 6587H"],
    "chapter": "4.4 指令寻址和数据寻址",
    "id": 15,
    "image": ""
  },
  {
    "question": "某计算机指令为16位，由低到高0到7位是位移量D，8到9位为寻址特征位X，10到15位为操作码.当X=00时直接寻址；当X=01时使用X1进行变址寻址；当X=10时使用X2进行变址寻址；当X=11时使用PC相对寻址.设(PC)=1234H4，(X1)=0005H，(X2)=1188H，则指令2222H的有效地址是( ). ",
    "options": ["A. 1256H", "B. 0027H", "C. 2222H", "D. 11AAH"],
    "chapter": "4.4 指令寻址和数据寻址",
    "id": 16,
    "image": ""
  },
  {
    "question": "假设相对寻址的转移指令占两个字节，第一个字节是操作码，第二个字节是相对偏移量(补码)表示).每当CPU从存储器取出一个字节PC自动加一.若当前PC值为1234H，1234H处指令为JMP*5(*为相对寻址特征)，则执行完这条指令后PC的值为( )",
    "options": ["A. 1236H", "B. 1239H", "C. 1235H", "D. 1237H"],
    "chapter": "4.4 指令寻址和数据寻址",
    "id": 17,
    "image": ""
  },
  {
    "question": "【2009】某机器字长为16位，主存按字节编址，转移指令采用相对寻址，由两个字节组成，第一个字节为操作码字段，第二个字节为相对偏移量字段.假定取指令时，每取一个字节PC自动加1.若某转移指令所在的主存地址为2000H，相对偏移量字段的内容为06H，则该转移指令成功转移后的目标地址是( ).",
    "options": ["A. 2006H", "B. 2007H", "C. 2008H", "D. 2009H"],
    "chapter": "4.4 指令寻址和数据寻址",
    "id": 26,
    "image": ""
  },
  {
    "question": "【2011】偏移寻址通过将某个寄存器内容与一个形式地地址相加而生成有效地址.下列寻址方式中，不属于偏移寻址的是( ).",
    "options": ["A. 间接寻址", "B. 基址寻址", "C. 相对寻址", "D. 变址寻址"],
    "chapter": "4.4 指令寻址和数据寻址",
    "id": 27,
    "image": ""
  },
  {
    "question": "【2013】假设变址寄存器R的内容为1000H，指令中的形式地址为2000H；地址1000H中的内容为2000H，地址2000H中的内容为3000H，地址3000H中的内容为4000H，则变址寻址方式下访问到的操作数是( )",
    "options": ["A. 1000H", "B. 2000H", "C. 3000H", "D. 4000H"],
    "chapter": "4.4 指令寻址和数据寻址",
    "id": 28,
    "image": ""
  },
  {
    "question": "【2014】某计算机有16个通用寄存器，采用32位定长指令字，操作码字段(含寻址方式位)为\n8位，Store指令的源操作数和目的操作数分别采用寄存器直接寻址和基址寻址方式.若基地寄存器可使用任一通用寄存器，偏移量用补码表示，则Storie指令中偏移量的取值范围是( ).",
    "options": [
      "A. -32768 ~ +32767",
      "B. -32767 ~ +32768",
      "C. -65536 ~ +65535",
      "D. -65535 ~ +65536"
    ],
    "chapter": "4.4 指令寻址和数据寻址",
    "id": 29,
    "image": ""
  },
  {
    "question": "【2016】某指令格式如下所示.其中M为寻址方式，I为变址寄存器编号，D为形式地址.若采用先变址后间址的寻址方式，则操作数的有效地址是( ).",
    "options": ["A. I+D", "B. (I)+D", "C. ((I)+D)", "D. ((I))+D"],
    "chapter": "4.4 指令寻址和数据寻址",
    "id": 30,
    "image": "/image/4_4_30.png"
  },
  {
    "question": "【2017】下列寻址方式中，最适合按下标顺序访问一维数线且元素的是( )",
    "options": ["A. 相对寻址", "B. 寄存器寻址", "C. 直接寻址", "D. 变址寻址"],
    "chapter": "4.4 指令寻址和数据寻址",
    "id": 31,
    "image": ""
  },
  {
    "question": "【2018】按字节编址的计算机中，某double型数组A的首地址为2000H，使用变址寻址和循环结构访问数组A，保存数组下标的变址寄存器初值为0，每次循环取一个数组元素，其偏移地址为变址值乘以sizeof(double)，取完后变址寄存器内容自动力1.若某次循环所取元素的地址为2100H，则进入该次循环时变址寄存器的内容是( ).",
    "options": ["A. 25", "B. 32", "C. 64", "D. 100"],
    "chapter": "4.4 指令寻址和数据寻址",
    "id": 32,
    "image": ""
  },
  {
    "question": "【2019】某计算机采用大端方式，按字节编址.某指令中操作数的机器数为1234FF00H，该操作数采用基址寻址方式，形式地址(用补码表示)为FF12H，基址寄存器内容为F0000000H，则该操作数的LSB(最低有效字节)所在的地址是( ).",
    "options": [
      "A. F000 FF12H",
      "B. F000 FF15H",
      "C. EFFF FF12H",
      "D. EFFF FF15H"
    ],
    "chapter": "4.4 指令寻址和数据寻址",
    "id": 33,
    "image": ""
  },
  {
    "question": "【2020】计算机采用16位定长指令字格式，操作码位数和寻址方式位数固定，指令系统有48条指令，支持直接、间接、立即、相对4种寻址方式.单地址指令中，直接寻址方式的可寻址范围是( ).",
    "options": ["A. 0~255", "B. 0~1023", "C. -128~127", "D. -512~511"],
    "chapter": "4.4 指令寻址和数据寻址",
    "id": 34,
    "image": ""
  },
  {
    "question": "下列对RISC描述正确的有( ).",
    "options": ["A. I、II", "B. III", "C. III、V", "D. 没有正确选项"],
    "chapter": "4.5 CISC和RISC的基本概念",
    "id": 1,
    "image": ""
  },
  {
    "question": "以下叙述中正确的是( )",
    "options": [
      "A. RISC机一定采用流水线技术",
      "B. 采用流水线技术的机器一定是RISC机",
      "C. CISC机一定不采用流水线技术",
      "D. RISC一定比CISC机指令执行的速度快"
    ],
    "chapter": "4.5 CISC和RISC的基本概念",
    "id": 2,
    "image": ""
  },
  {
    "question": "下列属于RISC的特征的是( )\nI.采用指令流水线    II.控制器采用微程序设计\nIV.只有LOAD/STORE指令访问存储器    III.指令长度固定\nV.难以用优化编译技术生成高效的目标代码",
    "options": [
      "A. I、III、IV",
      "B. II、III、IV",
      "C. I、II、III",
      "D. III IV、V"
    ],
    "chapter": "4.5 CISC和RISC的基本概念",
    "id": 3,
    "image": ""
  },
  {
    "question": "影响程序性能的因素包括算法、编程语言、编译程序以及指令集架构，以及关于它们之间关系正确的描述是( ).",
    "options": [
      "A. 算法决定源程序指令数量，但不影响程序CPI值",
      "B. 不同指令集架构会影响到指令数量和CPI的值",
      "C. 不同编译器生成的指令数量不相同，但是CPI值相同",
      "D. 不同的编程语言不影响编译器生成指令的数量，但会改变程序CPI值"
    ],
    "chapter": "4.5 CISC和RISC的基本概念",
    "id": 4,
    "image": ""
  },
  {
    "question": "【2009】下列关于RISC的叙述中，错误的是( )",
    "options": [
      "A. RISC普遍采用微程序控制器",
      "B. RISC大多数指令在一个时钟周期内完成",
      "C. RISC的内部通用寄存器数量相对CISC多",
      "D. RISC的指令数、寻址方式和指令格式种类相对CISC少"
    ],
    "chapter": "4.5 CISC和RISC的基本概念",
    "id": 5,
    "image": ""
  },
  {
    "question": "以下有关编程语言和机器结构关系的叙述中，错误的是( ).",
    "options": [
      "A. 机器语言程序就是由机器指令序列构成的程序",
      "B. 汇编语言是一种与机器结构无关的编程语言",
      "C. 高级语言程序和汇编语言程序都不能被机器直接执行",
      "D. 汇编语言程序中每条汇编指令一定有对应的一条机器指令"
    ],
    "chapter": "4.6 高级语言与机器级代码之间的对应",
    "id": 1,
    "image": ""
  },
  {
    "question": "假定编译器对C源程序中的变量和MIPS中等存器进行了以下对应：变量f、g、h、i、j分别对应寄存器$50、$S1、$S2、$S3、$S4，一条C语言赋值语句编高译后生成如下代码序列.这条 C语言赋值语句是( ).\n\nand $t0， $S1， $S2\nSub $t1， $S3， $S4\nSub $S0， $t1， $t0",
    "options": [
      "A. f = (i-j)-(g&h)",
      "B. f = (i-j)",
      "C. f = (i-j)-(g+h)",
      "D. f = (g+h)-(i-j)"
    ],
    "chapter": "4.6 高级语言与机器级代码之间的对应",
    "id": 2,
    "image": ""
  },
  {
    "question": "某小端(Little Endian)模式处理器的减法指令“sub ax，imm“自的功能为(ax)-imm→ax，imm 表示立即数，该指令对应的十六进制机器码为2DXXXX(从左到右以字节为单位由低地址到高地址)，其中XXXX对应imm的机器码，如果imm=-3，(ax)=7，则该指令对应的机器码和执行后OF标志位的值分别为( ).",
    "options": ["A. 2DFFFD、0", "B. 2DFFFD、1", "C. 2DFDFF、0", "D. 2DFDFF、1"],
    "chapter": "4.6 高级语言与机器级代码之间的对应",
    "id": 3,
    "image": ""
  },
  {
    "question": "嵌套或递归程序中需要把子程序返回地址放在( )中.",
    "options": ["A. 寄存器", "B. 缓存", "C. 堆栈", "D. 磁盘"],
    "chapter": "4.6 高级语言与机器级代码之间的对应",
    "id": 4,
    "image": ""
  },
  {
    "question": "子程序调用指令完整的功能是( )",
    "options": [
      "A. 改变堆栈指针SP的值",
      "B. 改变程序计数器PC的值",
      "C. 改变程序计数器PC的值和堆栈指针SP的值",
      "D. 改变地址寄存器的值"
    ],
    "chapter": "4.6 高级语言与机器级代码之间的对应",
    "id": 5,
    "image": ""
  },
  {
    "question": "下列有关栈和栈帧的叙述中错误的是( ).",
    "options": [
      "A. 找由若干个栈帧组成，每个栈帧对应一个过程或子程序",
      "B. CPU中通常有一个栈指针寄存器用来存放找顶位置",
      "C. 栈帧中存放着过程的局部变量、参数和返回地址",
      "D. 过程返回时应修改栈指针释放对应栈帧"
    ],
    "chapter": "4.6 高级语言与机器级代码之间的对应",
    "id": 6,
    "image": ""
  },
  {
    "question": "在CPU中，以下部件，不属于控制器的是( ).",
    "options": [
      "A. 时序电路",
      "B. 存储器数据寄存器",
      "C. 程序状态字寄存器",
      "D. 程序计数器"
    ],
    "chapter": "5.1 CPU的功能和基本结构",
    "id": 1,
    "image": ""
  },
  {
    "question": "在CPU中，(可用于传送和暂存用户数据，为ALU执行算术逻辑运算提供工作区.",
    "options": [
      "A. 程序计数器",
      "B. 累加寄存器",
      "C. 程序状态字寄存器",
      "D. 地址寄存器"
    ],
    "chapter": "5.1 CPU的功能和基本结构",
    "id": 2,
    "image": ""
  },
  {
    "question": "CPU内部，多个部件如果要共享1条总线，则每个器件与总线之间需要设置1个常用的器件， CPU控制该器件的状态，实现某个部件与总线的连接或断开千.该常用的器件是( ).",
    "options": ["A. 触发器", "B. 多路选择器", "C. 三态门", "D. 分线器"],
    "chapter": "5.1 CPU的功能和基本结构",
    "id": 3,
    "image": ""
  },
  {
    "question": "转移指令的主要操作是( ) ",
    "options": [
      "A. 改变地址缓存器的值",
      "B. 改变程序计数器的值",
      "C. 改变堆栈指针的值",
      "D. 改变指令寄存器的值"
    ],
    "chapter": "5.1 CPU的功能和基本结构",
    "id": 4,
    "image": ""
  },
  {
    "question": "某机的机器学长为32位，存储器按字编址，读取一条双字长指令后，PC值应自动加( ).",
    "options": ["A. 1", "B. 2", "D. 8", "C. 4"],
    "chapter": "5.1 CPU的功能和基本结构",
    "id": 5,
    "image": ""
  },
  {
    "question": "在某计算机系统中，已知A为累加器，SP为堆栈指示器，Msp为SP指示的找顶单元，如果进栈操作的顺序是(A)→Msp，(SP)+1→SP，那么出栈操作的顺序应为 ",
    "options": [
      "A. (M<sup>sp</sup>)→A，(SP)-1→SP",
      "B. (M<sup>sp</sup>)→A，(SP)+1→SP",
      "C. (SP)-1→SP，(M<sup>sp</sup>)→A",
      "D. (SP)+1→SP，(M<sup>sp</sup>)→A"
    ],
    "chapter": "5.1 CPU的功能和基本结构",
    "id": 6,
    "image": ""
  },
  {
    "question": "已知某计算机为定点整数计算机，其中央处理器的通用寄存器为16位，若(R0)=FFF9H，则有如下结论( ).",
    "options": [
      "A. 中央处理机的位数为16位；寄存器R0的真值为65529",
      "B. 中央处理机的位数为16位；寄存器R0的真值无法确定",
      "C. 中央处理机的位数为16位；寄存器R0的真值为-7",
      "D. 中央处理机的位数无法确定；寄存器R0的真值为-7"
    ],
    "chapter": "5.1 CPU的功能和基本结构",
    "id": 7,
    "image": ""
  },
  {
    "question": "用以指定待执行指令所在地址的是( ) ",
    "options": ["A. PC", "B. IR", "C. SP", "D. PSW"],
    "chapter": "5.1 CPU的功能和基本结构",
    "id": 8,
    "image": ""
  },
  {
    "question": "当执行一条指令时，先把它从指令Cache存储器读出，，然后再传送至( ).",
    "options": ["A. IR寄存器", "B. AC寄存器", "C. PC寄存器", "D. SP寄存器"],
    "chapter": "5.1 CPU的功能和基本结构",
    "id": 9,
    "image": ""
  },
  {
    "question": "程序计数器PC的位数决定了( ",
    "options": [
      "A. 机器字长",
      "B. 可寻址的最大内存空间",
      "C. 指令字长",
      "D. 数据总线的宽度"
    ],
    "chapter": "5.1 CPU的功能和基本结构",
    "id": 10,
    "image": ""
  },
  {
    "question": "【2010】下列寄存器中，汇编语言程序员可见的是( ).",
    "options": [
      "A. 存储器地址寄存器(MAR)",
      "B. 程序计数器(PC)",
      "C. 存储器数据寄存器(MDR)",
      "D. 指令寄存器(IR)"
    ],
    "chapter": "5.1 CPU的功能和基本结构",
    "id": 12,
    "image": ""
  },
  {
    "question": "【2016】某计算机主存空间为4GB，字长为32位，按字节编址，采用32位定长指令字格式.若指令按字边界对齐存放，则程序计数器(PC)和指令寄存器(IR)的位数至少分别是( ).",
    "options": ["A. 30、30", "B. 30、32", "C. 32 30", "D. 32、32"],
    "chapter": "5.1 CPU的功能和基本结构",
    "id": 13,
    "image": ""
  },
  {
    "question": "【2019】下列有关处理器时钟脉冲信号的叙述中，错误的是( ).",
    "options": [
      "A. 时钟脉冲信号由机器脉冲源发出的脉冲信号经整形和分频后形成",
      "B. 时钟脉冲信号的宽度称为时钟周期，时钟周期的倒数为机器主频",
      "C. 时钟周期以相邻状态单元间组合逻辑电路的最大延迟为基准确定",
      "D. 处理器总是在每来一个时钟脉冲信号时就开始执行一条新的指令"
    ],
    "chapter": "5.1 CPU的功能和基本结构",
    "id": 14,
    "image": ""
  },
  {
    "question": "【2021】下列寄存器中，汇编语言程序员可见的是( ).\nI.指令寄存器 II.微指令寄存器 III.基址寄存器 IV.标志/状态寄存器",
    "options": ["A. 仅I、II", "B. 仅I、IV", "C. 仅II、IV", "D. 仅III、IV"],
    "chapter": "5.1 CPU的功能和基本结构",
    "id": 15,
    "image": ""
  },
  {
    "question": "下列有关指令周期的叙述中，错误的是( ).",
    "options": [
      "A. 指令周期的第一个阶段一定是取指令阶段",
      "B. 乘法指令和加法指令的指令周期总是一样长",
      "C. 一个指令周期由若干个机器周期或时钟周期组成",
      "D. 单周期CPU中的指令周期就是一个时钟周期"
    ],
    "chapter": "5.2 指令执行过程",
    "id": 1,
    "image": ""
  },
  {
    "question": "若某条指令的处理时间分为取指令周期、执行周期和中断周期.获取该条指令需要3μs，执行该指令需要7μs，在该指令结束时，CPU处于开中断状态、且中断源的中断请求信号已到达，若关中断、保存断点、中断服务程序入口地址送PC共需3μs，中断服务程序的执行时间为100μs.则该指令的处理时间是( ) ",
    "options": ["A. 7μs", "B. 10μs", "D. 113μs", "C. 13μs"],
    "chapter": "5.2 指令执行过程",
    "id": 2,
    "image": ""
  },
  {
    "question": "某CPU指令系统共有5条不同指令，执行的步骤数目分别是4、10、6、7、8.取指令需要3个步骤，每一个步骤需要消耗一个时钟周期.现在使所有打指令的处理时间相等，则指令处理周期是( )个CPU时钟周期.",
    "options": ["A. 7", "B. 10", "C. 11", "D. 13"],
    "chapter": "5.2 指令执行过程",
    "id": 3,
    "image": ""
  },
  {
    "question": "下列关于机器字长、存储字长和指令字长的说法中，正确的是( ).\nI.为了方便硬件设计，指令字长通常是机器字长的整数倍\nII.为了方便硬件设计，指令字长通常等于存储字长\nIII.若指令字长与机器字长相等，则取指周期等于机器周期\nIV.若指令字长与存储字长相等，则取指周期等于机器周期",
    "options": ["A. 只有I", "B. 只有IV", "C. I、III", "D. II、IV"],
    "chapter": "5.2 指令执行过程",
    "id": 4,
    "image": ""
  },
  {
    "question": "下列选项中，与CPU主时钟的周期相同的是( ).",
    "options": ["A. CPU周期", "B. 机器周期", "C. 节拍周期", "D. 节拍脉冲"],
    "chapter": "5.2 指令执行过程",
    "id": 5,
    "image": ""
  },
  {
    "question": "指令周期是指( ).",
    "options": [
      "A. CPU从主存取出一条指令的时间",
      "B. CPU执行一条指令的时间",
      "C. CPU从主存取出条指令加上CPU执行这条指令的时间",
      "D. 时钟周期时间"
    ],
    "chapter": "5.2 指令执行过程",
    "id": 6,
    "image": ""
  },
  {
    "question": "下列说法中，合理的是( ).",
    "options": [
      "A. 执行各条指令的机器周期数相同，各机器周期的长度相同",
      "B. 执行各条指令的机器周期数相同，各机器周期的长度可变",
      "C. 执行各条指令的机器周期数可变，各机器周期的长度相同",
      "D. 执行各条指令的机器周期数可变，各机器周期的长度可变"
    ],
    "chapter": "5.2 指令执行过程",
    "id": 7,
    "image": ""
  },
  {
    "question": "在冯·诺依曼计算机中，CPU区分从存储器中取出的是指令还是数据的方法是( ).",
    "options": [
      "A. 指令和数据所在的存储单元地址不同",
      "B. 访问指令和访问数据所处的指令执行阶段不同",
      "C. 访问指令和访问数据的寻址方式不同",
      "D. 指令和数据表示方式不同"
    ],
    "chapter": "5.2 指令执行过程",
    "id": 8,
    "image": ""
  },
  {
    "question": "数值数据和逻辑数据在形式上没有任何差别，计算机区别数值数据和逻辑数据的主要方法是",
    "options": [
      "A. 将数值数据和逻辑数据分开存放在不同的寄存器中",
      "B. 在数据中用专门的标识位指出是数值数据还是逻辑数据",
      "C. 用不同的指令操作码来区分本指令处理的是哪种数据",
      "D. 用不同的时间段来区分当时处理的是哪种数据"
    ],
    "chapter": "5.2 指令执行过程",
    "id": 9,
    "image": ""
  },
  {
    "question": "下列有关CPU时钟信号的叙述中，正确的是( ) ",
    "options": [
      "A. 计算机系统中所有时钟的时钟周期都是一样的",
      "B. 时钟周期总是等于最复杂的指令所需要的执行时间",
      "C. 处理器总是每来一个时钟信号就开始执行一条新的指令",
      "D. 每个时钟周期称为一个节拍，机器的主频就是时钟周期的倒数"
    ],
    "chapter": "5.2 指令执行过程",
    "id": 10,
    "image": ""
  },
  {
    "question": "以下关于单周期计算机描述正确的是( ",
    "options": [
      "A. 每条指令只需要一个时钟周期，因此效率较高",
      "B. 其数据和指令都可以存放在同一个存储器中",
      "C. 其时钟周期长度取决于执行时间最短的指令的时长",
      "D. 其时钟周期长度取决于执行时间最长的指令的时长"
    ],
    "chapter": "5.2 指令执行过程",
    "id": 11,
    "image": ""
  },
  {
    "question": "【2011】假定不采用Cache和指令预取技术，且机器处于“开中断“状态，则在下列有关指令执行的叙述中，错误的是( ).",
    "options": [
      "A. 每个指令周期中CPU都至少访问内存一次",
      "B. 每个指令周期一定大于或等于一个CPU时钟周期",
      "C. 空操作指令的指令周期中任何寄存器的内容都不会被改变",
      "D. 当前程序在每条指令执行结束时都可能被外部中断打断"
    ],
    "chapter": "5.2 指令执行过程",
    "id": 13,
    "image": ""
  },
  {
    "question": "【2019】某指令功能为R[r2]<-R[r1]+M[R[r0]]，其两个源操作教分别采用寄存器、寄存器间接寻址方式.对于下列给定部件，该指令在取数及执行过程中需要用到的是( ).\nI.通用寄存器组(GPRs) II.算术逻辑单元(ALU) III.存储器(Memory) IV.指令译码器(ID)",
    "options": [
      "A. 仅I、II",
      "B. 仅I、II、III",
      "C. 仅II、III、IV",
      "D. 仅I、III、IV"
    ],
    "chapter": "5.2 指令执行过程",
    "id": 14,
    "image": ""
  },
  {
    "question": "在程序执行过程中，( )控制计算机的运行总是处于取指令、分析指令和执行指令的循环之中.",
    "options": ["A. 控制器", "B. CPU", "C. 指令存储器", "D，指令译码器"],
    "chapter": "5.3 数据通路的功能和基本结构",
    "id": 1,
    "image": ""
  },
  {
    "question": "CPU的读/写控制信号的作用包括( ).\nI.决定数据总线上的数据流方向\nII.控制存储器操作(读/写)的类型\nIII.控制流入、流出存储器信息的方向",
    "options": ["A. I、II", "В. II、III", "С. I、 III", "D. I、II、III"],
    "chapter": "5.3 数据通路的功能和基本结构",
    "id": 2,
    "image": ""
  },
  {
    "question": "下列关于单周期数据通路和多周期数据通路的说法中，正确的是( ) ",
    "options": [
      "A. 单周期处理器的CPI总比多周期处理器的CPI大",
      "B. 单周期处理器的时钟周期通常比多周期处理器的时钟周期短",
      "C. 在一条指令执行过程中，单周期处理器中的每个控制信号取值一直不变，而多周期处理器中的控制信号可能会发生改变",
      "D. 在一条指令执行过程中，单周期数据通路中和多周期数据通路中的每个部件都可使用多次"
    ],
    "chapter": "5.3 数据通路的功能和基本结构",
    "id": 3,
    "image": ""
  },
  {
    "question": "某机器的指令集中包含R-R型运算指令、分支指令Branch、无条件跳转指令Jump、取数指令 Load和存数指令Store.若使用单周期数据通路实现此指令系统，且各主要功能部件的操作时间分别为：指令存储器和数据存储器都是4ns；ALU和加法器都是1ns；通用寄存器组的读和写都是2ns.若忽略多路选择器、控制单元、程序计数器、符号扩展单元和传输线路等延迟，则该计算机时钟周期至少为( ).",
    "options": ["A. 7ns", "B. 9ns", "C. 11ns", "D. 13ns"],
    "chapter": "5.3 数据通路的功能和基本结构",
    "id": 4,
    "image": ""
  },
  {
    "question": "CPU内部线路通常采用总线连接方式.总线上，信号流动的原则是( ).\nI.每个时刻只有1个器件发出信息\nII.每个时刻有1个或多个器件发出信息\nIII.每个时刻只有1个器件接收信息\nIV.每个时刻有1个或多个器件接收信息",
    "options": ["A. I、III", "B. I、IV", "C. II、III", "D. II、IV"],
    "chapter": "5.3 数据通路的功能和基本结构",
    "id": 5,
    "image": ""
  },
  {
    "question": "【2010】下列选项中，能缩短程序执行时间的措施是( ).\nI.提高CPU时钟频率\nII.优化数据通路结构\nIII.对程序进行编译优化",
    "options": ["A. 仅I和II", "B. 仅I和III", "C. 仅II和III", "D. I、II和III"],
    "chapter": "5.3 数据通路的功能和基本结构",
    "id": 12,
    "image": ""
  },
  {
    "question": "【2016】单周期处理器中所有指令的指令周期为一个时钟周期.下列关于单周期处理器的叙述中，错误的是( ).",
    "options": [
      "A. 可以采用单总线结构数据通路",
      "B. 处理器时钟频率较低",
      "C. 在指令执行过程中控制信号不变",
      "D. 每条指令的CPI为1"
    ],
    "chapter": "5.3 数据通路的功能和基本结构",
    "id": 13,
    "image": ""
  },
  {
    "question": "【2021】下列关于数据通路的叙述中，错误的是( ).",
    "options": [
      "A. 数据通路包含ALU等组合逻辑(操作)元件",
      "B. 数据通路包含寄存器等时序逻辑(状态)元件",
      "C. 数据通路不包含用于异常事件检测及响应的电路",
      "D. 数据通路中的数据流动路径由控制信号进行控制"
    ],
    "chapter": "5.3 数据通路的功能和基本结构",
    "id": 14,
    "image": ""
  },
  {
    "question": "在微程序控制方式中，由( )形成微程序的入口地址.",
    "options": [
      "A. 机器指令的地址码",
      "B. 机器指令的操作码",
      "C. 微指令的微地址",
      "D. 微指令的操作码"
    ],
    "chapter": "5.4 控制器的功能和工作原理",
    "id": 1,
    "image": ""
  },
  {
    "question": "下列关于微指令的说法中，错误的是( ).\nI.字段直接编码方式可以用较少的二进制位数表示较多的微损操作命令.如果有两组互斥的微命令，每组微命令的个数分别为4和9，则分别只需要2位和4位即可表示\nII.直接编码方式不用进行译码操作，微命令字段中的每一位都代表一个微命令\nIII.垂直型微指令用较长的微程序结构换取较短的微指令结构，所以在执行效率和灵活性两方面都高于水平型微指令\nIV.在字段间接编码方式中，某个字段的译码输出需要依靠另外某个字段的输",
    "options": ["A. 只有II", "B. I、II", "С. I、III", "D. II、III、IV"],
    "chapter": "5.4 控制器的功能和工作原理",
    "id": 2,
    "image": ""
  },
  {
    "question": "下列关于同步控制和异步控制的说法中，错误的是( ).",
    "options": [
      "A. 同步控制适用于CPU内部控制",
      "B. 同步控制是所有指令执行时间都相同的方式",
      "C. 并步控制没有基准时钟信号，没有固定的周期节拍和严格的时钟同步",
      "D. 异步控制常用于CPU访问外围设备时"
    ],
    "chapter": "5.4 控制器的功能和工作原理",
    "id": 3,
    "image": ""
  },
  {
    "question": "下列关于机器指令与微指令关系的陈述中，正确的是美( ).",
    "options": [
      "A. 每条机器指令通过一条微指令解释执行",
      "B. 每条机器指令由一段微程序解释执行",
      "C. 每条微指令由若干条机器指令解释执行",
      "D. 每条机器指令由若干段微程序解释执行"
    ],
    "chapter": "5.4 控制器的功能和工作原理",
    "id": 4,
    "image": ""
  },
  {
    "question": "下列关于微操作的描述正确的是( ).",
    "options": [
      "A. 同一CPU周期中，可以并行执行的微操作叫相容性微操作",
      "B. 同一CPU周期中，可以并行执行的微操作叫相斥性微操作",
      "C. 在执行过程中可能会引起总线冲突的微操作叫相斥性微操作",
      "D. 同一CPU周期中，不可以并行执行的微操作叫相容性微操作"
    ],
    "chapter": "5.4 控制器的功能和工作原理",
    "id": 5,
    "image": ""
  },
  {
    "question": "下列叙述中( )是错误的.",
    "options": [
      "A. 采用微程序控制器的处理器称为微处理器",
      "B. 在微指令编码中，编码效率最低的是直接编码方式",
      "C. 在各种微地址形成方式中，增量计数器法需要的顺序控制字段较短",
      "D. CMAR是控制器中存储地址寄存器"
    ],
    "chapter": "5.4 控制器的功能和工作原理",
    "id": 6,
    "image": ""
  },
  {
    "question": "控制存储器用来存放( ).",
    "options": [
      "A. 控制程序",
      "B. 微程序",
      "C. 汇编语言程序",
      "D. 高级语言程序"
    ],
    "chapter": "5.4 控制器的功能和工作原理",
    "id": 7,
    "image": ""
  },
  {
    "question": "从总体上看，微程序控制器的速度相比组合逻辑电路要慢，主要原因在于( ).",
    "options": [
      "A. 增加了从指令寄存器读取微指令的时间",
      "B. 增加了从控制存储器读取微指令的时间",
      "C. 增加了从磁盘存储器读取微指令的时间",
      "D. 增加了从主存储器读取微指令的时间"
    ],
    "chapter": "5.4 控制器的功能和工作原理",
    "id": 8,
    "image": ""
  },
  {
    "question": "某计算机采用微程序控制器.微指令中的操作控制字段采用字段直接编码方式，共有34个微命令，构成5个互斥段，分别包含8、3、12、5和6个微令，则微指令的操作控制字段至少有( ).",
    "options": ["A. 5位", "B. 6位", "C. 16位", "D. 15位"],
    "chapter": "5.4 控制器的功能和工作原理",
    "id": 9,
    "image": ""
  },
  {
    "question": "在微程序控制器设计中，微指令采用单地址格式，控制存储器；为16K×4bit，那么微程序计数器 µPC应设计为( )位.",
    "options": ["D. 32", "A. 14", "B. 16", "C. 24"],
    "chapter": "5.4 控制器的功能和工作原理",
    "id": 10,
    "image": ""
  },
  {
    "question": "水平型微指令的特点是( ",
    "options": [
      "A. 采用微程序",
      "B. 控制信号直接控制",
      "C. 采用微操作码",
      "D. 多层次表示"
    ],
    "chapter": "5.4 控制器的功能和工作原理",
    "id": 11,
    "image": ""
  },
  {
    "question": "垂直型微指令的特点是( ).",
    "options": [
      "A. 微指令格式垂直表示",
      "B. 控制信号经过编码",
      "C. 采用微操作码",
      "D. 多层次表示"
    ],
    "chapter": "5.4 控制器的功能和工作原理",
    "id": 12,
    "image": ""
  },
  {
    "question": "组合逻辑控制器中，微操作信号的形成主要与( )有关.",
    "options": [
      "A. 指令操作码",
      "B. 指令译码信号和时钟信号",
      "C. 指令地址码",
      "D. 状态信号与条件"
    ],
    "chapter": "5.4 控制器的功能和工作原理",
    "id": 13,
    "image": ""
  },
  {
    "question": "【2009】相对于微程序控制器，硬布线控制器的特点是( ).",
    "options": [
      "A. 指令执行速度慢，指令功能的修改和扩展容易",
      "B. 指令执行速度慢，指令功能的修改和扩展难",
      "C. 指令执行速度快，指令功能的修改和扩展容易",
      "D. 指令执行速度快，指令功能的修改和扩展难"
    ],
    "chapter": "5.4 控制器的功能和工作原理",
    "id": 16,
    "image": ""
  },
  {
    "question": "【2012】某计算机的控制器采用微程序控制方式，微指令中的操作控制字段采用字段直接编码法，共有33个微命令，构成5个互斥类，分别包含7、3、12、5和6个微命令，则操作控制字段至少有",
    "options": ["A. 5位", "B. 6位", "C. 15位", "D. 33位"],
    "chapter": "5.4 控制器的功能和工作原理",
    "id": 17,
    "image": ""
  },
  {
    "question": "【2014】某计算机采用微程序控制器，共有32条指令，公共的取指令微程序包含2条微指令，各指令对应的微程序平均由4条微指令组成，采用断定法(下地址字段法)确定下条微指令地址，则微指令中下址字段的位数至少是( ).",
    "options": ["A. 5", "B. 6", "8", "D. 9"],
    "chapter": "5.4 控制器的功能和工作原理",
    "id": 18,
    "image": ""
  },
  {
    "question": "【2017】下列关于主存储器(MM)和控制存储器(CS)由的叙述中，错误的是( ",
    "options": [
      "A. MM在CPU外，CS在CPU内",
      "B. MM按地址访问，CS按内存访问",
      "C. MM存储指令和数据，CS存储微指令",
      "D. MM用RAM和ROM实现，CS用ROM实现"
    ],
    "chapter": "5.4 控制器的功能和工作原理",
    "id": 19,
    "image": ""
  },
  {
    "question": "下列关于隐指令的说法中，正确的是( ).",
    "options": [
      "A. 隐指令是操作数隐含在操作码中的指令",
      "B. 隐指令可以在一个机器周期里完成全部操作",
      "C. 隐指令是一种特殊的、允许用户使用的指令",
      "D. 隐指令是指令系统中没有的指令"
    ],
    "chapter": "5.5 异常和中断机制",
    "id": 1,
    "image": ""
  },
  {
    "question": "下列关于中断的说法中，正确的是( ).\nI.中断标志触发器用来指示CPU进入中断周期\nII.允许中断触发器用来开放/关闭中断系统\nIII.响应中断的条件是中断源有请求或者中断允许触发器置“1“时\nIV.响应中断的时机是每条指令执行周期的结束时刻",
    "options": ["A. I、II、III", "B. I、II、IV", "С. II、IV", "D. I、II、IV"],
    "chapter": "5.5 异常和中断机制",
    "id": 2,
    "image": ""
  },
  {
    "question": "单级中断系统中，CPU一旦响应中断，应立即执行下面的( )动作，以避免在中断响应的过程中响应其他中断源造成的干扰.",
    "options": [
      "A. 关中断",
      "B. 清除中断请求标志",
      "C. 禁止DMA",
      "D. 清除该中断源的中断屏蔽位"
    ],
    "chapter": "5.5 异常和中断机制",
    "id": 3,
    "image": ""
  },
  {
    "question": "在单级中断系统中，CPU一旦响应中断，则立即把( )标志置1，以防本次中断服务结束前同级的其他中断源产生另一次中断进行干扰.",
    "options": ["A. 中断允许", "B. 中断请求", "C. 中断屏蔽", "D. 中断保护"],
    "chapter": "5.5 异常和中断机制",
    "id": 4,
    "image": ""
  },
  {
    "question": "以下操作通过中断隐指令完成的是( ).",
    "options": [
      "A. 保护现场",
      "B. 保护断点",
      "C. 设置中断屏蔽字",
      "D. 从I/O接口取数据"
    ],
    "chapter": "5.5 异常和中断机制",
    "id": 5,
    "image": ""
  },
  {
    "question": "CPU响应中断的时间是( ).",
    "options": [
      "A. 取址周期结束",
      "B. 中断源提出请求",
      "C. 执行周期结束",
      "D. 存储周期结束"
    ],
    "chapter": "5.5 异常和中断机制",
    "id": 6,
    "image": ""
  },
  {
    "question": "中断向量给出的是( ).",
    "options": [
      "A. 程序断点",
      "B. 中断码",
      "C. 中断屏蔽码",
      "D. 中断服务程序的入口地址"
    ],
    "chapter": "5.5 异常和中断机制",
    "id": 7,
    "image": ""
  },
  {
    "question": "时钟中断事件属于( ).",
    "options": [
      "A. 自愿性中断事件",
      "B. 程序性中断事件",
      "C. I/O中断事件",
      "D. 外部中断事件"
    ],
    "chapter": "5.5 异常和中断机制",
    "id": 8,
    "image": ""
  },
  {
    "question": "中断发生时，必须保护的信息有( ).",
    "options": [
      "A. 处理器状态和所有寄存器内容",
      "B. 返回地址和所有寄存器内容",
      "C. 处理器状态和返回地址",
      "D. 处理器状态、返回地址和所有寄存器内容"
    ],
    "chapter": "5.5 异常和中断机制",
    "id": 9,
    "image": ""
  },
  {
    "question": "由程序中执行了中断指令引起的中断，也称为( ).",
    "options": ["A. 内部异常中断", "B. 外部中断", "C. I/O中断", "D. 软中断"],
    "chapter": "5.5 异常和中断机制",
    "id": 10,
    "image": ""
  },
  {
    "question": "缺页中断就是访问的页面不在主存而需要操作系统通过I/O将其调入主存引起的中断.这种中断属于( ).",
    "options": [
      "A. 内部异常中断",
      "B. 外部中断",
      "C. 用户请求得到中断",
      "D. 软中断"
    ],
    "chapter": "5.5 异常和中断机制",
    "id": 11,
    "image": ""
  },
  {
    "question": "在中断处理或子程序调用过程中，一般将返回地址保存在( ",
    "options": [
      "A. 程序计数器中",
      "B. 通用寄存器中",
      "C. 堆栈中",
      "D. 地址寄存器中"
    ],
    "chapter": "5.5 异常和中断机制",
    "id": 12,
    "image": ""
  },
  {
    "question": "有关中断的论述不正确的是( ).",
    "options": [
      "A. CPU及I/O设备可实现并行工作，但设备之间不可并行工作",
      "B. 可以实现多道程序、分时操作、实时操作等",
      "C. 对高速外设(如磁盘)采用中断可能引起数据丢失",
      "D. 计算机的中断源可来自主机，也可以来自外设"
    ],
    "chapter": "5.5 异常和中断机制",
    "id": 13,
    "image": ""
  },
  {
    "question": "【2009】下列选项中，能引起外部中断的事件是( ).",
    "options": ["A. 键盘输入", "B. 除数为0", "C. 浮点运算下溢", "D. 访存缺页"],
    "chapter": "5.5 异常和中断机制",
    "id": 15,
    "image": ""
  },
  {
    "question": "【2010】单级中断系统中，中断服务程序内的执行顺序是( ).",
    "options": [
      "A. I→V→VI→II→VII",
      "B. III→I→V→VII",
      "C. II→IV→V→VI→VII",
      "D. IV→I→V→VI→VII"
    ],
    "chapter": "5.5 异常和中断机制",
    "id": 16,
    "image": ""
  },
  {
    "question": "【2012】响应外部中断的过程中，中断隐指令完成的操作作，除保护断点外，还包括( ).\nI.关中断  II.保存通用寄存器的内容\nIII.形成中断服务程序入口地址并送PC",
    "options": ["A. 仅I、II", "B. 仅I、III", "C. 仅II、III", "D. I、II、III"],
    "chapter": "5.5 异常和中断机制",
    "id": 17,
    "image": ""
  },
  {
    "question": "【2012】中断处理和子程序调用都需要压栈以保护现场，中断处处理一定会保存而子程序调用不需要保存其内容的是( ).",
    "options": [
      "A. 程序计数器",
      "B. 程序状态字寄存器",
      "C. 通用数据寄存器",
      "D. 通用地址寄存器"
    ],
    "chapter": "5.5 异常和中断机制",
    "id": 18,
    "image": ""
  },
  {
    "question": "【2015】内部异常(内中断)可分为故障(fault)、陷阱(trap)和终止(abort)三类.下列有关内部异\n常的叙述中，错误的是( ",
    "options": [
      "A. 内部异常的产生与当前执行指令相关",
      "B. 内部异常的检测由CPU内部逻辑实现",
      "C. 内部异常的响应发生在指令执行过程中",
      "D. 内部异常处理后返回到发生异常的指令继续执行"
    ],
    "chapter": "5.5 异常和中断机制",
    "id": 19,
    "image": ""
  },
  {
    "question": "【2015】处理外部中断时，应该由操作系统保存的是( ",
    "options": [
      "A. 程序计数器(PC)的内容",
      "B. 通用寄存器的内容",
      "C. 快表(TLB)中的内容",
      "D. Cache中的内容"
    ],
    "chapter": "5.5 异常和中断机制",
    "id": 20,
    "image": ""
  },
  {
    "question": "【2015】假定下列指令已装入指令等存器，则执行时不可能导致CPU从用户态变为内核态(系统态)的是( ).",
    "options": [
      "A. DIV R0， R1； (R0)/(R1) R0",
      "B. INT n；产生软中断",
      "C. NOT R0；寄存器R0的内容取非",
      "D. MOV R0，addr；把地址addr处的内存数据放入寄存器R0中"
    ],
    "chapter": "5.5 异常和中断机制",
    "id": 21,
    "image": ""
  },
  {
    "question": "【2020】下列关于“自陷“(Trap，也称陷阱)的叙述中，错误的是( ).",
    "options": [
      "A. 自陷是通过陷阱指令预先设定的一类外部中断事件",
      "B. 自陷可用于实现程序调试时的断点设置和单步跟踪",
      "C. 自陷发生后CPU将转去执行操作系统内核相应程序",
      "D. 自陷处理完成后返回到陷阱指令的下一条指令执行"
    ],
    "chapter": "5.5 异常和中断机制",
    "id": 22,
    "image": ""
  },
  {
    "question": "【2020】下列事件中，属于外部中断事件的是( )\nI.访存时缺页\nII.定时器到时\nIII.网络数据包到达",
    "options": ["A. 仅I、II", "B. 仅I、III", "C. 仅II、III", "D. I、II和III"],
    "chapter": "5.5 异常和中断机制",
    "id": 23,
    "image": ""
  },
  {
    "question": "【2020】外部中断包括不可屏蔽中断(NMI) 和可屏蔽中断，下列关于外部中断的叙述中，错误的是( ).",
    "options": [
      "A. CPU处于关中断状态时，也能响应NMI请求",
      "B. 一旦可屏蔽中断请求信号有效，CPU将立即响应",
      "C. 不可屏蔽中断的优先级比可屏蔽中断的优先级高",
      "D. 可通过中断屏蔽字改变可屏蔽中断的处理优先级"
    ],
    "chapter": "5.5 异常和中断机制",
    "id": 24,
    "image": ""
  },
  {
    "question": "下列关于结构冒险的论述中，正确的有( )\nI.结构冒险指的是有多条指令要同时使用同一个资源\nII.避免结构冒险的基本做法是使每个指令在相同流水段中使用相同的部件\nIII.设置重复的功能部件可以避免结构冒险\nIV.指令Cache和数据Cache互相分离可以避免两条指后令同时分别访问数据和指令的冒险",
    "options": ["A. I、II、III", "B. I、II、IV", "C. II、IV", "D. I、III、IV"],
    "chapter": "5.6 指令流水线",
    "id": 1,
    "image": ""
  },
  {
    "question": "下列关于分支预测的论述中，正确的是\n\nI.分支预测技术可用于处理控制冒险和数据冒险\nII.使用静态预测技术时，每次的预测结果是一样的\nIII.动态预测技术通常比静态预测技术的预测成功率高\nIV.若预测错误，已被错误地放入流水线执行的指令必须被舍弃",
    "options": ["A. I、II、III", "B. I、II、IV", "C. II、IV", "D. I、III、IV"],
    "chapter": "5.6 指令流水线",
    "id": 2,
    "image": ""
  },
  {
    "question": "以下是一段MIPS指令序列，若使用“取指、译码/取数文、执行、访存、写回“的5段流水线方式，且使用“转发“技术.为了使这段程序不发生数据冒险，需在第3条指令前加入( )条空操作(nop)指令.",
    "options": ["A. 0", "B. 1", "C. 2", "D. 3"],
    "chapter": "5.6 指令流水线",
    "id": 3,
    "image": "/image/5_6_3.png"
  },
  {
    "question": "通过编译程序将多条能够并行操作的指令组合成一条指令，这种技术称做( ).",
    "options": [
      "A. 超标量技术",
      "B. 超流水线技术",
      "C. 超长指令字技术",
      "D. 超字长技术"
    ],
    "chapter": "5.6 指令流水线",
    "id": 4,
    "image": ""
  },
  {
    "question": "下面关于超流水线的说法中，正确的是( ).",
    "options": [
      "A. 超流水线技术能够缩短原来流水线的处理器周期",
      "B. 超流水线技术能够在每个时钟周期内同时并发多条指令",
      "C. 超流水线技术把能够并行操作的多条指令组合成一条指令，该指令具有有多个操作码字段",
      "D. 超流水线技术的实质是时间换空间"
    ],
    "chapter": "5.6 指令流水线",
    "id": 5,
    "image": ""
  },
  {
    "question": "下面关于RISC机器的说法中，正确的是( ).",
    "options": [
      "A. 指令长度不固定，指令格式种类多，寻址方式多样",
      "B. 一定采用流水线技术",
      "C. 主要采用微程序控制方式",
      "D. 不重视编译优化工作"
    ],
    "chapter": "5.6 指令流水线",
    "id": 6,
    "image": ""
  },
  {
    "question": "把指令设计为多级流水线的目的，不包括下列选项( ).",
    "options": [
      "A. 提高时钟频率",
      "B. 解决数据冲突",
      "C. 提高指令执行的并行性",
      "D. 实现指令部件的复用"
    ],
    "chapter": "5.6 指令流水线",
    "id": 7,
    "image": ""
  },
  {
    "question": "五级流水线CPU正在执行某条指令的第二级流水阶段时，外部设备产生了一个DMA请求，则 CPU对该DMA请求响应的时机是( ).",
    "options": [
      "A. 立即响应",
      "B. 在该指令的第二流水阶段执行完毕后响应",
      "C. 在该指令的第三流水阶段执行完毕后响应",
      "D. 在该指令执行结束后响应"
    ],
    "chapter": "5.6 指令流水线",
    "id": 8,
    "image": ""
  },
  {
    "question": "在一个具有四级流水线的浮点加法器中，假设四个阶段的时间分别是T1=60ns、T2=50ns.T3=90ns,T4=80ns，则加法器流水线的时钟周期至少为X；如果采用同同样的逻辑电路，但不是流水线方式，则浮点加法所需的时间为Y.那么X和Y是( ).",
    "options": [
      "A. X=70ns，Y=280ns",
      "B. X=50ns，Y=90ns",
      "C. X=90ns，Y=280ns",
      "D. X=50ns，Y=280ns"
    ],
    "chapter": "5.6 指令流水线",
    "id": 9,
    "image": ""
  },
  {
    "question": "某计算机中，各种指令的CPI平均为8，CPU采用5级流水方式执行指令，流水线每拍为2个时钟周期.执行程序A时，共执行了2000条指令，此时流水线的加速比约为( ).",
    "options": ["A. 4.0", "B. 5.0", "C. 8.0", "D. 10.0"],
    "chapter": "5.6 指令流水线",
    "id": 10,
    "image": ""
  },
  {
    "question": "以下情况中会引起指令流水线阻塞的是(一)",
    "options": [
      "A. Cache缺失",
      "B. 访存冲突",
      "C. 执行空操作指令",
      "D. 指令数据相关"
    ],
    "chapter": "5.6 指令流水线",
    "id": 11,
    "image": ""
  },
  {
    "question": "假设指令流经某五级流水线的五个功能段的时间一次是80ns，80ns， 80ns，70mis，90ns和50ns，那么流水线的时钟周期至少是( ).",
    "options": ["A. 90ns", "B. 80ns", "C. 70ns", "D. 50ns"],
    "chapter": "5.6 指令流水线",
    "id": 12,
    "image": ""
  },
  {
    "question": "关于流水线，下面说法正确的是( ).",
    "options": [
      "A. 流水线实现比单周期实现简单",
      "B. 流水线减少了单条指令的执行时间",
      "C. 流水线增加了系统的吞吐量",
      "D. 在流水线中使用转发逻辑后，可以避免装载-使用指令的组赛"
    ],
    "chapter": "5.6 指令流水线",
    "id": 13,
    "image": ""
  },
  {
    "question": "结构冒险、数据冒险和控制冒险通常会引起流水线阻塞.分个支预测、指令调度、延迟槽、增加功\n能单元(比如加法器、ALU)等在处理器流水线层和编译层实现的技术均用于减少或者消除这些冒险引起的阻塞.在这些技术中，能同时减少或者消除结构冒险和数据冒险的技术是( ).",
    "options": [
      "A. 分支预测",
      "B. 指令调度",
      "C. 延迟槽",
      "D. 增加功能单元(比如加法器、ALU)"
    ],
    "chapter": "5.6 指令流水线",
    "id": 14,
    "image": ""
  },
  {
    "question": "考虑一个基本的五级流水线(IF，ID，EX，MEM，WB)其中(IF，ID，EX，MEM，WB)分别表示从内存取指令、指令译码、指令执行、访问内存和将结果写回到寄存器.假定上述每步所需的时间如下表所示：表中的时间包括执行操作的时间以及将各个步骤间产生的中间结果存储到寄存器中的时间.假设不存在冒险或是阻塞需要( )ps(时间单位)执行一条指令.",
    "options": ["A. 305", "B. 1525", "C. 1415", "D. 250"],
    "chapter": "5.6 指令流水线",
    "id": 15,
    "image": "/image/5_6_15.png"
  },
  {
    "question": "某计算机的指令流水线由五级流水线组成，一段10条汇编指令的程序，在五级流水线上能完全流水执行，该程序需要消耗的时钟周期数是( ).",
    "options": ["A. 10", "B. 14", "C. 15", "D. 50"],
    "chapter": "5.6 指令流水线",
    "id": 16,
    "image": ""
  },
  {
    "question": "在流水线处理器中，增加流水段数带来的影响是( ).\n\nI.减少时钟周期 II.降低CPI III.减少程序包含的指令数",
    "options": ["A. I", "B. III", "C. I和II", "D. II和III"],
    "chapter": "5.6 指令流水线",
    "id": 17,
    "image": ""
  },
  {
    "question": "CPU片上Cache分别采用独立的指令Cache和数据Cache的目的是( ).",
    "options": [
      "A. 增加Cache的容量",
      "B. 区分指令和数据",
      "C. 缓解流水线中的数据冒险冲突(数据相关冲突)",
      "D. 缓解流水线中的结构冒险冲突(资源相关冲突)"
    ],
    "chapter": "5.6 指令流水线",
    "id": 18,
    "image": ""
  },
  {
    "question": "【2009】某计算机的指令流水线由四个功能段组成，指令流经各功能段的时间(忽略各功能段之间的缓存时间)分别为90ns、80ns、70ns、和60ns，见创该计算机的CPU时钟周期是( ).",
    "options": ["A. 90ns", "B. 80ns", "C. 70ns", "D. 60ns"],
    "chapter": "5.6 指令流水线",
    "id": 26,
    "image": ""
  },
  {
    "question": "【2010】下列选项中，不会引起指令流水线阻塞的是( ).",
    "options": [
      "A. 数据旁路(转发)",
      "B. 数据相关",
      "C. 条件转移",
      "D. 资源冲突"
    ],
    "chapter": "5.6 指令流水线",
    "id": 27,
    "image": ""
  },
  {
    "question": "【2011】下列给出的指令系统特点中，有利于实现指4令流水线的是( ).\nI.指令格式规整且长度一致\nII.指令和数据按边界对齐存放\nIII.只有Load/Store指令才能对操作数进行存储方问",
    "options": ["A. 仅I、II", "B. 仅II、III", "C. 仅I、III", "D. I、II、III"],
    "chapter": "5.6 指令流水线",
    "id": 28,
    "image": ""
  },
  {
    "question": "【2013】某CPU主频为1.03GHz，采用4级指令流水线，每个流水段的执行需要1个时钟周期.\n假定CPU执行了100条指令，在其执行过程中，没有发生任何流水线阻塞，此时流水线的吞吐率为( ).",
    "options": [
      "A. 0.25×10<sup>9</sup>条指令/秒",
      "B. 0.97×10<sup>9</sup>条指令/秒",
      "C. 1.0×10<sup>9</sup>条指令/秒",
      "D. 1.03×10<sup>9</sup>条指令/秒"
    ],
    "chapter": "5.6 指令流水线",
    "id": 29,
    "image": ""
  },
  {
    "question": "【2016】在无转发机制的五段基本流水线(取指、译码/读寄存器、运算、访存、写回寄存器)中， 下列指令序列存在数据冒险的指令对是( ).",
    "options": ["A. I1和I2", "B. I2和I3", "C. I2和I4", "D. I3和I4"],
    "chapter": "5.6 指令流水线",
    "id": 30,
    "image": "/image/5_6_30.png"
  },
  {
    "question": "【2017】下列关于超标量流水线特性的叙述中，正确的；是( ).\nI.能缩短流水线功能段的处理时间\nII.能在一个时钟周期内同时发射多条指令\nIII.能结合动态调度技术提高指令执行并行性",
    "options": ["A. 仅II", "B. 仅I、III", "C. 仅II、III", "D. I、II和III"],
    "chapter": "5.6 指令流水线",
    "id": 31,
    "image": ""
  },
  {
    "question": "【2017】下列关于指令流水线数据通路的叙述中，错误的为是( ).",
    "options": [
      "A. 包含生成控制信号的控制部件",
      "B. 包含算术逻辑运算部件(ALU)",
      "C. 包含通用寄存器组和取指部件",
      "D. 由组合逻辑电路和时序逻辑电路组合而成"
    ],
    "chapter": "5.6 指令流水线",
    "id": 32,
    "image": ""
  },
  {
    "question": "【2018】若某计算机最复杂指令的执行需要完成5个子功能，分别由功能部件A~E实现，各功能部件所需时间分别为80ps、50ps、50ps、70ps和50ps，采用流水丝战方式执行指令，流水段寄存器延时为20ps，则CPU时钟周期至少为( ).",
    "options": ["A. 60ps", "B. 70ps", "C. 80ps", "D. 100ps"],
    "chapter": "5.6 指令流水线",
    "id": 33,
    "image": ""
  },
  {
    "question": "【2019】在采用“取指、译码/取数、执行、访存、写回“5段流水线处理器中，执行如下指令序列，其中s0、s1、s2、s3和t2表示寄存器编号.下列指令对中，不存在数据冒险的是( ).",
    "options": ["A. I1和I2", "B. I2和I3", "C. I2和I4", "D. I3和I4"],
    "chapter": "5.6 指令流水线",
    "id": 34,
    "image": "/image/5_6_34.png"
  },
  {
    "question": "【2020】下列给出的处理器类型中，理想情况下，CFI为1的是\nI.单周期CPU\nII.多周期CPU\nIII.基本流水线CPU\nIV.超标量流水线CPU",
    "options": ["A. 仅I、II", "B. 仅I、III", "C. 仅II、IV", "D. 仅III、IV"],
    "chapter": "5.6 指令流水线",
    "id": 35,
    "image": ""
  },
  {
    "question": "从体系结构角度来看，阵列处理机属于( )计算机.",
    "options": ["A. SISD", "B. SIMD", "C. MIMD", "D. MISD"],
    "chapter": "5.7 多处理器基本概念",
    "id": 1,
    "image": ""
  },
  {
    "question": "以下机器中，不属于SIMD机器的是( ).",
    "options": [
      "A. 并行处理机",
      "B. 阵列处理机",
      "C. 向量处理机",
      "D. 标量流水线处理机"
    ],
    "chapter": "5.7 多处理器基本概念",
    "id": 2,
    "image": ""
  },
  {
    "question": "下列关于集群计算机的表述中，不正确的是( ).",
    "options": [
      "A. 集群计算机是一个并行或分布式处理系统，它包含若干台：连接在一起的独立计算机",
      "B. 一个条群通常是指连接在一起的两或两台以上的计算机(节点)可以是物理上相连接的，也可以是物理上分散但通过网络相连接的",
      "C. 对于用户和应用程序来说，一个连接在一起的计算机集群是一个分布式的系统",
      "D. 随着微处理器和网络技术的进步，集群计算机应运而生，且被用来解决大规模计算问题"
    ],
    "chapter": "5.7 多处理器基本概念",
    "id": 3,
    "image": ""
  },
  {
    "question": "在多核处理器中，计算内核相同且地位对等的称为( )多核：计算内核不同且地位不对等的称为( )多核.",
    "options": [
      "A. 异构，同构",
      "B. 同构，异构",
      "C. 异构，异构",
      "D. 同构，同构"
    ],
    "chapter": "5.7 多处理器基本概念",
    "id": 4,
    "image": ""
  },
  {
    "question": "下列关于多核处理器的说法中，不正确的是( ).",
    "options": [
      "A. 多核处理器将多个处理器集成到一个芯片内，由各个处理器并行执行不同的进程",
      "B. 多核处理器实际上就是在一个CPU上集成了多个控制核心",
      "C. 将两个及以上的CPU整合在一起的处理器称为多核处理器",
      "D. 多核处理器是多处理器系统，在Flynn分类法中属于MIMD系统"
    ],
    "chapter": "5.7 多处理器基本概念",
    "id": 5,
    "image": ""
  },
  {
    "question": "下面关于对称多处理器(SMP)的说法中错误的是( ).",
    "options": [
      "A. 对称多处理器(SMP)在一个计算机上汇集了一组处理器，各处理器之间共享内存子系统以及总线结构",
      "B. 在对称多处理器(SMP)中系统将任务队列均匀地分发给多个处理器",
      "C. 将两个及以上的CPU整在对称多处理器(SMP)中，处理器之间不能相互通信合在一起的处理器称为多核处理器",
      "D. 在对称多处理器 (SMP)中，处理器路数一般为偶数个，比如2路，4路，6路，8路"
    ],
    "chapter": "5.7 多处理器基本概念",
    "id": 6,
    "image": ""
  },
  {
    "question": "冯·诺依曼计算机是( )体系结构.",
    "options": ["A. SISD", "B. SIMD", "C. MISD", "D. MIMD"],
    "chapter": "5.7 多处理器基本概念",
    "id": 7,
    "image": ""
  },
  {
    "question": "下面关于多核处理器的说法错误的是( ).",
    "options": [
      "A. 多核处理器并不能使单线程序的执行速度加速，但能多在特定时间内执行更多的任务",
      "B. 多核处理器中每个核心的主频有可能低于单核处理器的主频",
      "C. 多核处理器的出现能很好的解决内存瓶颈问题",
      "D. 在能耗上，多核处理器一般比单核处理器更加高效"
    ],
    "chapter": "5.7 多处理器基本概念",
    "id": 8,
    "image": ""
  },
  {
    "question": "下列选项中，不会在总线上传输的是( ).",
    "options": ["A. 数据信息", "B. 地址信息", "C. 控制信息", "D. 系统信息"],
    "chapter": "6.1 总线",
    "id": 1,
    "image": ""
  },
  {
    "question": "在计算机中使用总线固然有优点，但也存在缺点，包括( ).",
    "options": [
      "A. 不能同时传送数据信息和控制信息",
      "B. 不能同时传送地址信息和数据信息",
      "C. 不能同时传送地址信息和控制信息",
      "D. 不能同时在总线中传送两种信息源的信息"
    ],
    "chapter": "6.1 总线",
    "id": 2,
    "image": ""
  },
  {
    "question": "挂在总线上的多个部件( ).",
    "options": [
      "A. 可以同时向总线发送数据，且多个部件可以同时从总线接收数据",
      "B. 只能分时向总线发送数据，且多个部件可以同时从总线接收数据",
      "C. 可以同时向总线发送数据，但各个部件只能分时从总线接收数据",
      "D. 只能分时向总线发送数据，且各个部件只能分时从总线接收数据"
    ],
    "chapter": "6.1 总线",
    "id": 3,
    "image": ""
  },
  {
    "question": "下列关于同步总线的叙述，错误的是( ).",
    "options": [
      "A. 同步总线一般采用应答方式进行通信",
      "B. 同步总线的公共时钟一般取决于最慢的部件",
      "C. 同步总线一般用作CPU内部总线、处理器总线等",
      "D. 同步总线一般用在存取速度一致的部件之间"
    ],
    "chapter": "6.1 总线",
    "id": 4,
    "image": ""
  },
  {
    "question": "下列关于系统总线中的地址线的说法，正确的是( ).",
    "options": [
      "A. 地址总线的位数与机器字长有关",
      "B. 地址总线的位数与存储字长有关",
      "C. 地址总线的功能是用于传输内存和I/O设备接口电路的地址",
      "D. 地址总线的功能是用于选择外存和I/O设备接口电路的地址"
    ],
    "chapter": "6.1 总线",
    "id": 5,
    "image": ""
  },
  {
    "question": "下列信号中，可以在系统总线中的控制总线上传输的有( ).\n\nI.存储器和I/O设备的地址信息\nII.存储器和I/O设备的时序信号、控制信号\nIII.存储器和I/O设备响应信号\nIV.存储器中存放的数据",
    "options": ["A. I、IV", "B. II、III", "C. II、III、 IV", "D. I、II、III"],
    "chapter": "6.1 总线",
    "id": 6,
    "image": ""
  },
  {
    "question": "下面关于总线的说法哪个正确( ).",
    "options": [
      "A. 并行总线的速度大于串行总线",
      "B. 异步总线速度大于同步",
      "C. 单总线速度大于双总线",
      "D. 以上说法均错误"
    ],
    "chapter": "6.1 总线",
    "id": 7,
    "image": ""
  },
  {
    "question": "总线中，有些信息是单向传输的，有些信息是双向传输的为，下列说法中，正确的是( ).",
    "options": [
      "A. 数据信息是单向传输的，由内存或者外设传送至CPU",
      "B. 地址信息是单向传输的，由CPU发送至内存或者外设",
      "C. 控制信息是双向传输的，由CPU发送至内存或者外设，也可反向",
      "D. 状态信息是双向传输的，由CPU发送至内存或者外设，也可反向"
    ],
    "chapter": "6.1 总线",
    "id": 8,
    "image": ""
  },
  {
    "question": "下列关于总线的叙述中，正确的有( ).\n\nI.CPU通过指令的不同周期来识别总线传输过来的信息是地无址还是数据\nII.间接寻址第一次访存得到的数据经过系统总线的数据总线专送到CPU\nIII.在单总线结构中，访问I/O设备可以不使用I/O指令\nIV.在异步总线中，传送操作由设备控制器控制器控制",
    "options": ["A. I、III", "B. I、IV", "C. II、III", "D. I、II、III"],
    "chapter": "6.1 总线",
    "id": 9,
    "image": ""
  },
  {
    "question": "以下属于单总线特点的是( ).",
    "options": [
      "A. 可以减少CPU和各部件的连线，易于增删设备",
      "B. 传送速度快，大多数计算机都采用这种连接方式",
      "C. 可以匹配访存速度不一的设备，使得计算机系统刻女率更高",
      "D. 是从多总线优化发展而来的"
    ],
    "chapter": "6.1 总线",
    "id": 10,
    "image": ""
  },
  {
    "question": "下列关于总线结构的叙述中，错误的是( ).",
    "options": [
      "A. 在单总线结构中，CPU使用访存指令去访问外设",
      "B. 双总线结构需要增加通道等硬件设备",
      "C. 三总线结构中三条总线可以同时使用，系统效率高",
      "D. 在三总线结构中，可以使用DMA方式进行数据传输"
    ],
    "chapter": "6.1 总线",
    "id": 11,
    "image": ""
  },
  {
    "question": "在单机系统中采用的三总线结构是指哪三类总线？( ).",
    "options": [
      "A. 数据总线、地址总线和控制总线",
      "B. 主存总线、I/O总线和DMA总线",
      "C. 局部总线、系统总线和通信总线",
      "D. 电缆式总线、主板式总线和背板式总线"
    ],
    "chapter": "6.1 总线",
    "id": 12,
    "image": ""
  },
  {
    "question": "已知某支持突发(猝发)传输模式的同步总线的时钟频率为200MHz，宽度为32位，地址和数据线复用，每个时钟周期传输一个地址或数据，如果一次“存储器读“总线事物传输用的时间为25ns，则本次传输的有效数据位数是( ).",
    "options": ["A. 32位", "B. 128位", "C. 160位", "D. 256位"],
    "chapter": "6.1 总线",
    "id": 13,
    "image": ""
  },
  {
    "question": "某总线在一个总线周期中并行传送8个字节的数据，总线时钟频率是66MHz，每个总线周期等于一个总线时钟周期，则总线的带宽为( ).",
    "options": ["A. 528MB/s", "B. 132MB/s", "C. 264MB/s", "D. 66MB/s"],
    "chapter": "6.1 总线",
    "id": 14,
    "image": ""
  },
  {
    "question": "某总线共有64根数据和地址复用的信号线，总线时钟频率为33MHz 若总线上每个时钟周期传送一次数据，则该总线的带宽是( ).",
    "options": ["A. 2112MB/s", "B. 264MB/s", "C. 528MB/s", "D. 1056MB/s"],
    "chapter": "6.1 总线",
    "id": 15,
    "image": ""
  },
  {
    "question": "总线复用方式可以( ).",
    "options": [
      "A. 更快地传递信息和数据",
      "B. 同时传送多种信息，如同时传送地址和数据",
      "C. 减少总线中信号线的数量",
      "D. 增加总线的功能和可靠性"
    ],
    "chapter": "6.1 总线",
    "id": 16,
    "image": ""
  },
  {
    "question": "假设总线共有4根信号线，其中数据总线位数是16位，地址总线位数是8位，控制总线位数是20位，总线的工作频率为100MHz，那么总线宽度为和最大大传输速率为( ).",
    "options": [
      "A. 8bit， 200MB/s",
      "B. 16bit， 250MB/s",
      "C. 16bit， 200MB/s",
      "D. 20bit， 250MB/s"
    ],
    "chapter": "6.1 总线",
    "id": 17,
    "image": ""
  },
  {
    "question": "某计算机的总线时钟周期为40ns，系统总线能并行传输4：字节数据，每个总线周期占用4个时钟周期，则总线带宽是( ).",
    "options": ["A. 100Mbps", "B. 200Mbps", "C. 400Mbps", "D. 800Mbps"],
    "chapter": "6.1 总线",
    "id": 18,
    "image": ""
  },
  {
    "question": "影响总线带宽的因素有很多，其中不包括( ).\n\nI.总线宽度 II.总线频率 III.存储字长 IV.数据传输方式 V.数据字长",
    "options": ["A. 仅III", "B. III、V", "C. III、IV", "D. III、V"],
    "chapter": "6.1 总线",
    "id": 19,
    "image": ""
  },
  {
    "question": "下列关于USB、PCI总线特性的表迷中，正确的是( ).",
    "options": [
      "A. PCI总线是与处理器相关的高速外围总线，系统中可以有多条",
      "B. USB总线可通过级联方式连接多台外设，可同时传送多位.数据",
      "C. PCI总线和USB总线都属于串行总线",
      "D. PCI总线和USB总线都支持即插即用"
    ],
    "chapter": "6.1 总线",
    "id": 20,
    "image": ""
  },
  {
    "question": "下列各总线特性的叙述中，错误的是( ).",
    "options": [
      "A. USB总线、PCI-E总线、SATA总线都属于串行总线",
      "B. PCI-E总线是一种支持双向传输的局部总线",
      "C. AGP总线属于并行总线，其传输速度比PCI-E总线快",
      "D. USB总线是一种支持热插拔的高速串行总线"
    ],
    "chapter": "6.1 总线",
    "id": 21,
    "image": ""
  },
  {
    "question": "下列总线中，属于串行总线的是( ).",
    "options": [
      "A. PCI总线和ISA总线",
      "B. PCI总线和PCI-E总线",
      "C. USB总线和ISA总线",
      "D. USB总线和PCI-E总线"
    ],
    "chapter": "6.1 总线",
    "id": 22,
    "image": ""
  },
  {
    "question": "下列关于PCI总线特性的表述中不正确的是( ).",
    "options": [
      "A. 系统中可以有多条PCI总线",
      "B. 能实现即插即用",
      "C. PCI总线能够同时传送多位数据",
      "D. PCI总线是与处理器相关的高速外围总线"
    ],
    "chapter": "6.1 总线",
    "id": 23,
    "image": ""
  },
  {
    "question": "“总线忙“信号由( )建立.",
    "options": [
      "A. 获得总线控制权的设备",
      "B. 发出“总线请求“的设备",
      "C. 总线控制器",
      "D. CPU"
    ],
    "chapter": "6.1 总线",
    "id": 24,
    "image": ""
  },
  {
    "question": "在总线上的从设备是指( ).",
    "options": [
      "A. 发送数据的设备",
      "B. 总线操作的发起者",
      "C. 接收数据的设备",
      "D. 总线操作的对象"
    ],
    "chapter": "6.1 总线",
    "id": 25,
    "image": ""
  },
  {
    "question": "下列关于异步定时(通信)方式的叙述，错误的是( ).",
    "options": [
      "A. 异步通信方式只采用“握手“信号",
      "B. 在异步通信方式中，一个总线传输周期的过程是先传送地址，再传送数据",
      "C. 在各种异步通信方式中，全互锁方式速度最慢",
      "D. 异步通信的速度比同步通信方式具有更高的传输速率"
    ],
    "chapter": "6.1 总线",
    "id": 26,
    "image": ""
  },
  {
    "question": "在不同速度的设备之间传送数据，( ).",
    "options": [
      "A. 必须采用同步控制方式",
      "B. 必须采用异步控制方式",
      "C. 可以选用同步方式，也可选用异步方式",
      "D. 必须采用应答方式"
    ],
    "chapter": "6.1 总线",
    "id": 27,
    "image": ""
  },
  {
    "question": "在下列选项中，最适合采用异步传输方式的是( ).",
    "options": [
      "A. I/O接口与打印机之间传输数据",
      "B. CPU与内存之间传输数据",
      "C. CPU和总线之间传输数据",
      "D. CPU内部的各部件之间传输数据"
    ],
    "chapter": "6.1 总线",
    "id": 28,
    "image": ""
  },
  {
    "question": "某存储器总线使用同步通信方式，处理器时钟频率为100MHHz，每个总线事务以突发(猝发)方式传输16个字(每字2B)，用来支持块长为16个字的Cache行读/写.对于读操作，需要花费 1个时钟周期接收地址、3个时钟周期等待存储器准备数据、16个时钟周期用于传输16个字.若全部访问都是读操作，那么此存储器的数据传输速率为( ).",
    "options": ["A. 160Mb/s", "B. 200Mb/s", "C. 800Mb/s", "D. 1280Mb/s"],
    "chapter": "6.1 总线",
    "id": 29,
    "image": ""
  },
  {
    "question": "【2010】下列选项中的英文缩写均为总线标准的是( ).",
    "options": [
      "A. PCI、CRT、USB、EISA",
      "B. ISA、CPI、VESA、EISA",
      "C. ISA、SCSI、RAM、MIPS",
      "D. ISA、EISA、PCI、PCI-Express"
    ],
    "chapter": "6.1 总线",
    "id": 32,
    "image": ""
  },
  {
    "question": "【2011】在系统总线的数据线上，不可能传输的是( ).",
    "options": ["A. 指令", "B. 操作数", "C. 握手(应答)信号", "D. 中断类型号"],
    "chapter": "6.1 总线",
    "id": 33,
    "image": ""
  },
  {
    "question": "【2012】某同步总线的时钟频率为100MHz，宽度为32位，地址/数据线复用，每传输一个地址或数据占用一个时钟周期.若该总线支持突发(猝发)传输方式，则一次“主存写“总线事务传输128位数据所需要的时间至少是( ).",
    "options": ["A. 20ns", "B. 40ns", "C. 50ns", "D. 80ns"],
    "chapter": "6.1 总线",
    "id": 34,
    "image": ""
  },
  {
    "question": "【2012】下列关于USB总线特性的描述中，错误的是( ).",
    "options": [
      "A. 可实现外设的即插即用和热拔插",
      "B. 可通过级联方式连接多台外设",
      "C. 是一种通信总线，连接不同外设",
      "D. 同时可传输2位数据，数据传输率高"
    ],
    "chapter": "6.1 总线",
    "id": 35,
    "image": ""
  },
  {
    "question": "【2012】下列选项中，在I/0总线的数据线上传输的信息包括( ).\n\nI.I/O接口中的命令字 II.I/O接口中的状态字 III.中断类型号",
    "options": ["A. 仅I、II", "B. 仅I、III", "C. 仅II、III", "D. I、II、III"],
    "chapter": "6.1 总线",
    "id": 36,
    "image": ""
  },
  {
    "question": "【2013】下列选项中用于设备和设备控制器(I/0接口)之间互连的接口标准是美( ).",
    "options": ["A. PCI", "B. USB", "C. AGP", "D. PCI-Express"],
    "chapter": "6.1 总线",
    "id": 37,
    "image": ""
  },
  {
    "question": "【2014】某同步总线采用数据线和地址线复用方式，其中.地址/数据线有32根，总线时钟频率为 66MHz，每个时钟周期传送两次数据(上升沿和下降沿各传送送一次数据)，该总线的最大数据传输率(总线带宽)是( ).",
    "options": ["A. 132MB/s", "B. 264MB/s", "C. 528MB/s", "D. 1056MB/s"],
    "chapter": "6.1 总线",
    "id": 38,
    "image": ""
  },
  {
    "question": "【2014】一次总线事务中，主设备只需给出一个首地址，从人设备就能从首地址开始的若干连续单元读出或写入多个数据.这种总线事务方式称为( ).",
    "options": ["A. 并行传输", "B. 串行传输", "C. 突发传输", "D. 同步传输"],
    "chapter": "6.1 总线",
    "id": 39,
    "image": ""
  },
  {
    "question": "【2015】下列有关总线定时的叙述中，错误的是( ).",
    "options": [
      "A. 异步通信方式中，全互锁协议的速度最慢",
      "B. 异步通信方式中，非互锁协议的可靠性最差",
      "C. 同步通信方式中，同步时钟信号可由各设备提供",
      "D. 半同步通信方式中，握手信号的采样由同步时钟控制"
    ],
    "chapter": "6.1 总线",
    "id": 40,
    "image": ""
  },
  {
    "question": "【2016】下列关于总线设计的叙述中，错误的是( ).",
    "options": [
      "A. 并行总线传输比串行总线传输速度快",
      "B. 采用信号线复用技术可减少信号线数量",
      "C. 采用突发传输方式可提高总线数据传输率",
      "D. 采用分离事务通信方式可提高总线利用率"
    ],
    "chapter": "6.1 总线",
    "id": 41,
    "image": ""
  },
  {
    "question": "【2017】下列关于多总线结构的叙述中，错误的是( ).",
    "options": [
      "A. 靠近CPU的总线速度较快",
      "B. 总线之间须通过桥接器相连",
      "C. PCI-Express×16采用并行传输方式",
      "D. 总线之间可以是并行或串行连接"
    ],
    "chapter": "6.1 总线",
    "id": 42,
    "image": ""
  },
  {
    "question": "【2018】下列选项中，可提高同步总线数据传输率的是( ).\n\nI.增加总线宽度  II.提高总线工作频率  III.支持突发传输  IV.采用地址/数据线复用",
    "options": [
      "A. 仅I、II",
      "B. 仅I、II、III",
      "C. 仅III、IV",
      "D. I、II、III和IV"
    ],
    "chapter": "6.1 总线",
    "id": 43,
    "image": ""
  },
  {
    "question": "【2019】假定一台计算机采用3通道存储器总线，配套的内存条型号为DDR3-1333，即内存条所接插的存储器总线的工作频率为1333MHz、总线宽度为64位，则存储器总线的总带宽大约是( ).",
    "options": ["A. 10.66GB/s", "B. 32GB/s", "C. 64 GB/s", "D. 96GB/s"],
    "chapter": "6.1 总线",
    "id": 44,
    "image": ""
  },
  {
    "question": "【2020】QPI总线是一种点对点全双工同步串行总线，总线上的设备可同时接收和发送信息，每个方向可同时传输20位信息(16位数据+4位校验位)，每个QPI数据包有80位信息，分2 个时钟周期传送，每个时钟周期传递2次，因此QPI总线带宽为：每秒传送次数×2B×2.若 QPI时钟频率为2.4GHz，则总线带宽为( ).",
    "options": ["A. 4.8GB/s", "B. 9.6GB/s", "C. 19.2GB/s", "D. 38.4GB/s"],
    "chapter": "6.1 总线",
    "id": 45,
    "image": ""
  },
  {
    "question": "【2021】下列关于总线的叙述中，错误的是( ).",
    "options": [
      "A. 总线是在两个或多个部件之间进行数据交换的传输介质",
      "B. 同步总线由时钟信号定时，时钟频率不一定等于工作频率",
      "C. 异步总线由握手信号定时，一次握手过程完成一位数据交换",
      "D. 突发(Burst)传送总线事务可以在总线上连续传送多个数据"
    ],
    "chapter": "6.1 总线",
    "id": 46,
    "image": ""
  },
  {
    "question": "【2010】假定一台计算机的显示存储器用DRAM芯片实现，若要求显示分辨率为1600×1200， 颜色深度为24位，帧频为85Hz，显存总带宽的50%用来刷新屏幕，则需要的显存总带宽至少约为( ).",
    "options": ["A. 245Mbps", "B. 979Mbps", "C. 1958Mbps", "D. 7834Mbps"],
    "chapter": "6.2 I/O系统的基本概念",
    "id": 1,
    "image": ""
  },
  {
    "question": "下列功能中，属于I/0接口的功能的是( ).\nI.数据的缓冲\nII.数据的压缩与格式转换\nIII.I/O过程中状态检测\nIV.I/O操作的定时\nV.与主机和设备进行通信",
    "options": [
      "A. I、II、IV",
      "B. I、II、III、V",
      "C. I、III、V",
      "D. I、III、IV、V"
    ],
    "chapter": "6.3 I/O接口",
    "id": 1,
    "image": ""
  },
  {
    "question": "下列关于I/0接口的功能的叙述，错误的是( ).",
    "options": [
      "A. I/O接口可以解决主机和外设数据传送速度不一致的问题",
      "B. I/O接口可以解决主机和外设数据格式不一致的问题",
      "C. I/O接口可以对数据通信过程进行协调和控制",
      "D. I/O接口可以读取外设的出错情况"
    ],
    "chapter": "6.3 I/O接口",
    "id": 2,
    "image": ""
  },
  {
    "question": "下列关于I/0接口中各种信息传送的叙述中，正确的是( ).",
    "options": [
      "A. CPU通过状态总线读取状态寄存器中的状态信息",
      "B. CPU通过控制总线将控制信息发送到控制寄存器",
      "C. CPU通过数据总线将数据传送到数据缓冲寄存器",
      "D. CPU通过地址总线将地址信息发送到地址寄存器"
    ],
    "chapter": "6.3 I/O接口",
    "id": 3,
    "image": ""
  },
  {
    "question": "下列属于I/O接口中寄存器的有( ).\nI.指令寄存器\nII.控制寄存器\nIII.状态寄存器\nIV.地址寄存器\nV.数据缓冲寄存器",
    "options": ["A.I、II、III、V", "B. II、III、IV", "C. II、III、V", "D. II、III、IV、V"],
    "chapter": "6.3 I/O接口",
    "id": 4,
    "image": ""
  },
  {
    "question": "下列说法中，不正确的是( ).",
    "options": [
      "A. 统一编址方式下CPU需要设置专门的输入/输出指令访问可端口",
      "B. 数据端口和状态端口都称为I/O端口",
      "C. 输入端口和输出端口可以使用同一个I/O端口地址",
      "D. 输入端口只能输入数据或读入状态"
    ],
    "chapter": "6.3 I/O接口",
    "id": 5,
    "image": ""
  },
  {
    "question": "下列关于统一编址和独立编址的说法中，正确的是( ).\nI.在统一编址的方式下，依靠不同的地址码区分存储单元和口I/O设备\nII.在独立编址的方式下，依靠不同的指令区分存储单元和I/O设备\nIII.在独立编址方式下，I/0地址是存储地址的一部分\nIV.在两种方式下，都可以使用访存指令访问I/O设备",
    "options": ["A. I、II", "B. II、III", "C. II、III、IV", "D. I、II、III、IV"],
    "chapter": "6.3 I/O接口",
    "id": 6,
    "image": ""
  },
  {
    "question": "若菜个计算机系统中1/0地址统一编址，访问内存单元和1/0设备是靠( )未区分今的",
    "options": [
      "A. 不同的地址代码",
      "B. 数据总线上输出的数据",
      "C. 内存I/O设备使用不同的地址总线",
      "D. 不同的指令"
    ],
    "chapter": "6.3 I/O接口",
    "id": 7,
    "image": ""
  },
  {
    "question": "【2014】下列有关I/O接口的叙述中，错误的是( ).",
    "options": [
      "A. 状态端口和控制端口可以合用同一个寄存器",
      "B. I/O接口中CPU可访问的寄存器称为I/O端口",
      "C. 采用独立编址方式时，I/O端口地址和主存地址可能相同",
      "D. 采用统一编址方式时，CPU不能用访存指令访问I/O端口"
    ],
    "chapter": "6.3 I/O接口",
    "id": 8,
    "image": ""
  },
  {
    "question": "【2017】I/O指令实现的数据传送通常发生在( ).",
    "options": [
      "A. I/O设备和I/O端口之间",
      "B. 通用寄存器和I/O设备之间",
      "C. I/O端口和I/O端口之间",
      "D. 通用寄存器和I/O端口之间"
    ],
    "chapter": "6.3 I/O接口",
    "id": 9,
    "image": ""
  },
  {
    "question": "【2021】下列选项中，不属于I/O接口的是( ).",
    "options": [
      "A. 磁盘驱动器",
      "B. 打印机适配器",
      "C. 网络控制器",
      "D. 可编程中断控制器"
    ],
    "chapter": "6.3 I/O接口",
    "id": 10,
    "image": ""
  },
  {
    "question": "下列关于程序查询方式的叙述，正确的是( ).",
    "options": [
      "A. CPU在与硬盘交换信息时，一般采用程序查询方式",
      "B. 按启动查询方式的不同，可分为软件查询方式和硬件查询方式",
      "C. 适用于鼠标、针式打印机等字符类设备",
      "D. CPU需要一直查询外设的状态，直到设备准备就绪时才可可以去执行其他程序"
    ],
    "chapter": "6.4 I/O 方式",
    "id": 1,
    "image": ""
  },
  {
    "question": "下列关于程序查询方式工作过程的叙述，正确的是( ).",
    "options": [
      "A. 当CPU查询到外设状态没有准备就绪时，会重启外设",
      "B. CPU主要负责启动外设和查询其状态，不参与数据传送",
      "C. 当数据没有传送完时，CPU必须重启外设，继续进行下一轮传送",
      "D. 每完成一次数据传送后，会修改主存地址和计数值"
    ],
    "chapter": "6.4 I/O 方式",
    "id": 2,
    "image": ""
  },
  {
    "question": "在某台计算机中，处理器的主频为100MHz，处理器与硬盘之间通过程序中断的方式传输数据，每次最多传送4字节数据，传输速率为100KB/s，每次传输需要100个CPU时钟周期.那么 CPU处理硬盘I/O的时间占整个CPU时间的百分比是( ).",
    "options": ["A. 0.5%", "B. 2.5%", "C. 4%", "D. 5%"],
    "chapter": "6.4 I/O 方式",
    "id": 3,
    "image": ""
  },
  {
    "question": "假设某文本打印页面有60行，每行有40个字符，一台打印机每3秒打印一页，忽略将一个字符写入打印机的输出寄存器中的时间.假设打印一个字符需要10μs的中断时间开销，使用程序中断方式运行这台打印机，并使其持续工作，那么CPU用于处理I/0的时间占CPU的百分比为( ).",
    "options": ["A. 0.8%", "B. 1.25%", "C. 8%", "D. 12.5%"],
    "chapter": "6.4 I/O 方式",
    "id": 4,
    "image": ""
  },
  {
    "question": "某计算机系统中的CPU主频为100MHz，软盘驱动器使用程序中断方式与主机进行数据1/0，每次传送2字节数据，传输率为25KB/s，每次传输的所有开销是100个CPU时钟周期，忽略数据处理时间，则CPU用于处理I/O的时间占用CPU时间的百分比为( )",
    "options": ["A. 0.625%", "B. 1.25%", "C. 2.5%", "D. 5%"],
    "chapter": "6.4 I/O 方式",
    "id": 5,
    "image": ""
  },
  {
    "question": "下列选项中，发生中断请求的条件有( ).\nI.一条指令执行结束\nII.机器内部发生故障\nIII.一次I/O操作结束\nIV.一次DMA操作结束\nV.每个机器周期结束",
    "options": ["A. 仅I、II", "B. II、III、IV", "C. I、II、III", "D. 仅IV、V"],
    "chapter": "6.4 I/O 方式",
    "id": 6,
    "image": ""
  },
  {
    "question": "在I/0接口中设置中断触发器保存外设提交的中断请求，是因为( ).",
    "options": [
      "A. 中断不需要立即处理",
      "B. 中断设备的处理速度比CPU快",
      "C. CPU无法对发生的中断请求立即进行处理",
      "D. 可能有多个个中断同时发生"
    ],
    "chapter": "6.4 I/O 方式",
    "id": 7,
    "image": ""
  },
  {
    "question": "CPU检查中断请求的时刻为( )结束时.",
    "options": ["A. 时钟周期", "B. 节拍周期", "C. CPU周期", "D. 执行周期"],
    "chapter": "6.4 I/O 方式",
    "id": 8,
    "image": ""
  },
  {
    "question": "单级中断系统中，CPU一旦响应中断，应立即执行下面的动作，以避免在中断响应的过程中响应其他中断源造成的干扰( ).",
    "options": [
      "A. 关中断",
      "B. 清除中断请求标志",
      "C. 禁止DMA",
      "D. 清除该中断源的中断屏蔽位"
    ],
    "chapter": "6.4 I/O 方式",
    "id": 9,
    "image": ""
  },
  {
    "question": "下列关于中断响应的说法中，正确的是\nI.中断响应发生在一条指令执行的任何时刻\nII.中断响应发生在一条指令结束时\nIII.中断响应周期内CPU需：关中断、保存断点、发送中断响应信号并形成中断向量地址\nIV.中断响应周期内CPU需：关中断、执行中断服务程序",
    "options": ["A. I、III", "B. I、IV", "C. II、III", "D. II、IV"],
    "chapter": "6.4 I/O 方式",
    "id": 10,
    "image": ""
  },
  {
    "question": "关于程序中断和DMA方式的响应时机，下列说法中正确确的是( ).\nI.CPU在中断源提出请求时响应中断\nII.CPU在指令的执行周期结束时响应中断\nIII.CPU在当前指令周期结束时响应DMA请求\nIV.CPU在当前机器周期结束时响应DMA请求",
    "options": ["A. I、 III", "B. I、IV", "C. II、III", "D. II、IV"],
    "chapter": "6.4 I/O 方式",
    "id": 11,
    "image": ""
  },
  {
    "question": "如果同时发生了多个中断，系统会先响应优先级最高的中断请求，但可以使用( )调整中断事件的处理优先级.",
    "options": [
      "A. 多级中断技术",
      "B. 中断向量表",
      "C. 中断屏蔽码",
      "D. 中断处理程序"
    ],
    "chapter": "6.4 I/O 方式",
    "id": 12,
    "image": ""
  },
  {
    "question": "某设备中断请求的响应和处理时间为100ns，每400ns发出一次中断请求，中断响应所容许的最长延迟时间为50ns，则在该设备持续工作过程中CPU用于该设备的I/O时间占整个CPU时间百分比至少是( ).",
    "options": ["A. 12.5%", "B. 25%", "C. 37.5%", "D. 50%"],
    "chapter": "6.4 I/O 方式",
    "id": 13,
    "image": ""
  },
  {
    "question": "在具有中断向量表的计算机中，中断向量是指( ).",
    "options": [
      "A. 子程序的入口地址",
      "B. 中断向量表的首地址",
      "C. 中断服务程序的入口地址",
      "D. 中断服务程序入口地址的地址"
    ],
    "chapter": "6.4 I/O 方式",
    "id": 14,
    "image": ""
  },
  {
    "question": "假定CPU与外部设备以中断方式进行I/O操作.在CPU响应中断时，该设备发送给CPU的中断向量表指针是0400H，0400H单元中存放的值为2000H，2000H单元中存放的值为3000H， 那么该设备的中断服务程序在主存中的入口地址为( ).",
    "options": ["A. 0400H", "B. 2000H", "C. 2400H", "D. 3000H"],
    "chapter": "6.4 I/O 方式",
    "id": 15,
    "image": ""
  },
  {
    "question": "下列关于中断向量和中断服务程序的说法中，错误的是)",
    "options": [
      "A. 中断服务程序可以是操作系统的一个模块",
      "B. 中断向量法的好处是可以加快识别中断源的速度",
      "C. 中断向量实际上是中断服务程序的入口地址的地址",
      "D. 在硬件向量法中，向量内存单元存放中断服务程序的入口地址"
    ],
    "chapter": "6.4 I/O 方式",
    "id": 16,
    "image": ""
  },
  {
    "question": "为了方便实现多级中断，保护现场最好采用( )",
    "options": [
      "A. 堆栈，因为多级中断的进入和返回过程符合栈的特性",
      "B. 通用寄存器，因为将断点和现场保存至通用寄存器最快",
      "C. 主存，因为主存空间一般够用，且速度较快",
      "D. 外存，因为外存空间充足"
    ],
    "chapter": "6.4 I/O 方式",
    "id": 17,
    "image": ""
  },
  {
    "question": "中断发生时，必须保护的信息有( ).",
    "options": [
      "A. 处理器状态和所有寄存器内容",
      "B. 返回地址和CPU中某些通用寄存器的内容",
      "C. 处理器状态和返回地址",
      "D. 处理器状态、返回地址和所有寄存器内容"
    ],
    "chapter": "6.4 I/O 方式",
    "id": 18,
    "image": ""
  },
  {
    "question": "下列陈述中正确的是( ).",
    "options": [
      "A. 中断服务程序的最后一条指令是无条件转移指令",
      "B. 中断响应过程是仅由硬件完成的",
      "C. 每条指令的执行过程中，每个总线周期要检查一次有无中断请求",
      "D. 检测有无DMA请求，一般安排在一条指令执行过程的末尾"
    ],
    "chapter": "6.4 I/O 方式",
    "id": 19,
    "image": ""
  },
  {
    "question": "在不允许中断嵌套的系统中，中断服务程序依次完成的了工作是( ).",
    "options": [
      "A. 关中断、保存断点、保存现场、处理中断事件、恢复现场、开中断、中断返回",
      "B. 保存现场、开中断、处理中断事件、关中断、恢复现场、开中断、中断返回",
      "C. 保存现场、处理中断事件、恢复现场、开中断、中断返回",
      "D. 保存断点、保存现场、处理中断事件、恢复现场、中断运返回"
    ],
    "chapter": "6.4 I/O 方式",
    "id": 20,
    "image": ""
  },
  {
    "question": "下列关于中断和DMA的说法中，正确的是( ).\nI.中断服务程序的最后一条指令是中断返回指令\nII.在中断响应周期，由关中断指令将中断屏蔽触发器置“0\nIII.中断发生时，程序计数器内容的保护和更新由硬件自动完成\nIV.程序中断和DMA方式都是由软件和硬件相结合的I/O 方式",
    "options": ["A. I、III", "B. I、IV", "C. II、III", "D. II、III、IV"],
    "chapter": "6.4 I/O 方式",
    "id": 21,
    "image": ""
  },
  {
    "question": "某计算机有4级中断，其响应优先级从高到低分别为AA>B>C>D. 若要将中断处理优先级的顺序修改为C>A>D>B，则A、B、C、D级的中断屏蔽字分别别为( ).",
    "options": [
      "A. 1111、1011、0011、0001",
      "B. 1101、0100、1111、0101",
      "C. 1101、1111、0001、1001",
      "D. 1001、0001、1111、1101"
    ],
    "chapter": "6.4 I/O 方式",
    "id": 22,
    "image": ""
  },
  {
    "question": "某计算机有5级中断A、B、C、D、E，优先级从高到低分别为A>B>C>D>E.现使用中断屏蔽字修改优先级顺序，A中断的屏蔽字为11111，B中断的屏蔽字为01001，C中断的屏蔽字为 01111，D中断的屏蔽字为01011，E中断的屏蔽字为00001，那么现在的优先顺序从高到低为 ( ).",
    "options": ["A. A>B>C>D>E", "B. A>C>D>B>E", "C. B>C>E>A>D", "D. E>B>D>C>A"],
    "chapter": "6.4 I/O 方式",
    "id": 23,
    "image": ""
  },
  {
    "question": "下列关于外中断(除故障外)和DMA的说法中，正确的是( ).",
    "options": [
      "A. 外中断可分为可屏蔽中断和不可屏蔽中断，且可屏蔽中断优先级比不可屏蔽中断优先级高",
      "B. 中断请求优先级比DMA请求优先级高",
      "C. 不可屏蔽中断、可屏蔽中断和DMA请求都要在当前指令执行周期结束后才能被响应",
      "D. 即使没有打开中断，处理器也能响应不可屏蔽中断请求"
    ],
    "chapter": "6.4 I/O 方式",
    "id": 24,
    "image": ""
  },
  {
    "question": "下列关于DMA方式特点的叙述，错误的是( ).",
    "options": [
      "A. DMA方式中，主机和外设可以并行工作",
      "B. DMA方式中，CPU只参与预处理和后处理过程",
      "C. DMA方式只适用于高速设备",
      "D. DMA方式一定要用到中断处理"
    ],
    "chapter": "6.4 I/O 方式",
    "id": 25,
    "image": ""
  },
  {
    "question": "下列关于DMA的叙述中，错误的是",
    "options": [
      "A. 一种主要由硬件实现I/O交换的工作方式",
      "B. CPU只在指令周期结束时才能响应来自DMA的请求",
      "C. DMA传送过程中不需要处理器参与操作",
      "D. 每次DMA传送必须申请占用总线"
    ],
    "chapter": "6.4 I/O 方式",
    "id": 26,
    "image": ""
  },
  {
    "question": "某DMA通道有一个32bit的地址寄存器和一个16bit的计数寄存器，则单一的DMA处理中能传输的数据为( )",
    "options": ["A. 212B", "B. 216B", "C. 232B", "D. 248B"],
    "chapter": "6.4 I/O 方式",
    "id": 27,
    "image": ""
  },
  {
    "question": "下列关于DMA控制器的叙述，错误的是( ).\nI.主存地址寄存器主要用来存放需要交换数据的主存地址\nII.字计数器主要用来存放已传送数据的字数\nIII.DMA接口与主存、外设之间均以字节为单位进行传送\nIV.设备地址寄存器用来存放I/0设备码",
    "options": ["A. 仅I", "B. II、III", "C. II、IV", "D. I、III、IV"],
    "chapter": "6.4 I/O 方式",
    "id": 28,
    "image": ""
  },
  {
    "question": "下列关于DMA传送数据前的叙述，正确的是( ).",
    "options": [
      "A. 外部设备向DMA控制器发送总线请求信号",
      "B. DMA控制器向CPU发送DMA请求信号",
      "C. CPU发出DMA响应信号，并获得总线控制权",
      "D. CPU发出总线响应信号，DMA控制器获得总线控制权"
    ],
    "chapter": "6.4 I/O 方式",
    "id": 29,
    "image": ""
  },
  {
    "question": "DMA访问主存时，让CPU处于等待状态，等DMA将数据传送结束后，CPU恢复工作，这种方式属于( ).",
    "options": ["A. 停止CPU访存", "B. 交替分时访存", "C. 周期挪用", "D. 中断"],
    "chapter": "6.4 I/O 方式",
    "id": 30,
    "image": ""
  },
  {
    "question": "若DMA采用周期窃取方式传送数据，则每传送一个字常禹占用一个( )的时间.",
    "options": ["A. 指令周期", "B. 机器周期", "C. 总线周期", "D. 存储周期"],
    "chapter": "6.4 I/O 方式",
    "id": 31,
    "image": ""
  },
  {
    "question": "目前计算机系统中普遍采用的DMA控制器与CPU交换总线控制权的方式是( ).",
    "options": ["A. 周期挪用", "B. 交替访存", "C. 停止CPU", "D. 扩展时钟周期"],
    "chapter": "6.4 I/O 方式",
    "id": 32,
    "image": ""
  },
  {
    "question": "假设主存速度不高于CPU的访存速度，当DMA控制器欲与CPU进行总线控制权交换时，采用( )方式对CPU工作效率影响较小.",
    "options": ["A. 周期挪用", "B. 交替访存", "C. 停止CPU", "D. 扩展时钟周期"],
    "chapter": "6.4 I/O 方式",
    "id": 33,
    "image": ""
  },
  {
    "question": "在DMA方式中，实现CPU和DMA接口分时使用主存，下面说法中正确的是( ).",
    "options": [
      "A. 在停止CPU访问主存的方法中，DMA在传送数据时独占主存，CPU放弃总线的控制权",
      "B. 在周期挪用方法中，I/O设备一旦有DMA请求，就挪用一个存耳及周期，此时CPU处于不工\n作状态或保持原状态",
      "C. DMA与CPU交替访存方式，将主存的存取周期分成两个时间片，一片分给CPU，一片分\n给DMA",
      "D. 以上说法都正确"
    ],
    "chapter": "6.4 I/O 方式",
    "id": 34,
    "image": ""
  },
  {
    "question": "下列关于DMA的说法中，正确的是( ).",
    "options": [
      "A. 若DMA请求和中断请求同时发生，通常情况下，DMA请求会先得到响应",
      "B. 通过DMA方式将数据从内存传送到外设读数据时，数据经过的路径是内存→CPU→数据\n总线外设",
      "C. DMA方式下的数据传送仅由硬件就可完成",
      "D. DMA的周期窃取需要等当前总线周期结束后才能启动"
    ],
    "chapter": "6.4 I/O 方式",
    "id": 35,
    "image": ""
  },
  {
    "question": "在DMA的接口电路中，程序中断部件的作用是( )",
    "options": [
      "A. 实现数据传送",
      "B. 向CPU请求总线使用权",
      "C. 报告CPU传输结束",
      "D. 启动数据传输"
    ],
    "chapter": "6.4 I/O 方式",
    "id": 36,
    "image": ""
  },
  {
    "question": "下面关于中断和DMA的叙述中，正确的是( ).",
    "options": [
      "A. DMA中没有中断机制",
      "B. CPU和DMA可以同时使用总线",
      "C. DMA的数据传送需要由CPU控制",
      "D. 一个高优先级的中断请求不一定能中断一个低优先级的中断处理程序的执行"
    ],
    "chapter": "6.4 I/O 方式",
    "id": 37,
    "image": ""
  },
  {
    "question": "下列关于DMA方式的说法中，正确的是( ).",
    "options": [
      "A. DMA方式在I/O设备和I/O设备之间建立了一条直接的.数据通路",
      "B. 在DMA方式下，数据的传送不需要经过CPU",
      "C. 在DMA方式中，由DMA控制器发出DMA请求",
      "D. 以上说法都正确"
    ],
    "chapter": "6.4 I/O 方式",
    "id": 38,
    "image": ""
  },
  {
    "question": "假设磁盘采用DMA方式与主机交换信息，其传输速率为4MBps，而且DMA的预处理需1000个时钟周期，DMA完成传送后处理中断需500个时钟周期.如果平均传输的数据长度为6KB， 试问在硬盘工作时，50MHz的处理器进行DMA辅助操作(预处理和后处理)需用的时间比率为( ).",
    "options": ["A. 1.5%", "B. 2%", "C. 3.5%", "D. 4%"],
    "chapter": "6.4 I/O 方式",
    "id": 39,
    "image": ""
  },
  {
    "question": "下列关于程序中断方式和DMA方式的表述中，正确的是( ).\nI.程序中断的优先级比DMA的优先级要高\nII.程序中断方式需要保护现场，而DMA方式不需要保护现场\nIII.程序中断方式需要用到中断，而DMA方式不需要用到中断\nIV.两种方式都需要用到中断，但目的不同.",
    "options": ["A. I、III", "B. II、III", "C. I、IV", "D. II、IV"],
    "chapter": "6.4 I/O 方式",
    "id": 40,
    "image": ""
  },
  {
    "question": "在中断I/O方式中，处理器与外设( )工作；在DMA，方式中，数据传送与主程序( )工作.",
    "options": [
      "A. 串行；串行",
      "B. 串行；并行",
      "C. 并行；串行",
      "D. 并行；并行"
    ],
    "chapter": "6.4 I/O 方式",
    "id": 41,
    "image": ""
  },
  {
    "question": "下列关于程序查询方式、程序中断方式和DMA方式的叙述中，正确的是( ).",
    "options": [
      "A. 程序查询方式中有中断请求，而DMA方式不需要中断请求",
      "B. 程序查询方式和DMA方式中都需要中断请求，且二者目的相同",
      "C. 程序中断方式和DMA方式中都需要中断请求，但二者目的不同",
      "D. DMA方式要在指令周期结束时才能进行周期窃取"
    ],
    "chapter": "6.4 I/O 方式",
    "id": 42,
    "image": ""
  },
  {
    "question": "下列关于中断和DMA的说法中，正确的是( ).\nI.执行指令时，每个机器周期结束都要检查一次有无中断清求\nII.由硬件和中断服务程序共同完成程序中断\nIII.中断服务程序的最后一条指令是跳转指令\nIV.一般在一条指令执行结束时检测有无DMA请求",
    "options": ["A. 仅II", "B. I、II", "C. I、III", "D. II、IV"],
    "chapter": "6.4 I/O 方式",
    "id": 43,
    "image": ""
  },
  {
    "question": "以下有关I/O方式的叙述中，错误的是( ).",
    "options":[
      "A. 程序查询方式和中断方式下，数据传送都通过执行指令来完成",
      "B. DMA方式下，外设接口中的数据和主存单元中的内容直接交换",
      "C. 中断I/O方式下，外设接口中的数据和通用寄存器的内容直接交换",
      "D. 中断方式下的额外开销(额外指令执行时间)比程序查向方式下的更小"
    ],
    "chapter": "6.4 I/O 方式",
    "id": 44,
    "image": ""
  },
  {
    "question": "【2010】单级中断系统中，中断服务程序内的执行顺序是( ).\nI.保护现场  II.开中断  III.关中断  IV.保存断点 V.中断事件处理 VI.恢复现场 VII.中断返回 ",
    "options": [
      "A. I→V→VI→II-VII",
      "B. III→I→V→VII",
      "C. III→IV→V→VI→VII",
      "D. IV→I-V→VI→VII"
    ],
    "chapter": "6.5 中断",
    "id": 57,
    "image": ""
  },
  {
    "question": "【2011】某计算机有五级中断L<sub>4</sub>~L<sub>0</sub>，中断屏蔽字为M<sub>4</sub>M<sub>3</sub>M<sub>2</sub>M<sub>1</sub>M<sub>0</sub>，M<sub>i</sub>=1(0<i<4)表示对L级中断进行屏蔽.若中断响应优先级从高到低的顺序文是L<sub>0</sub>→L<sub>1</sub>→L<sub>2</sub>→L<sub>3</sub>→L<sub>4</sub>，且要求中断处理优先级从高到低的顺序为L<sub>4</sub>→L<sub>0</sub>→L<sub>2</sub>→L<sub>1</sub>→L<sub>3</sub>，则L<sub>1</sub>的中断处理程序中设置的中断屏蔽字是( ).",
    "options": ["A. 11110", "B. 01101", "C. 00011", "D. 01010"],
    "chapter": "6.5 中断",
    "id": 58,
    "image": ""
  },
  {
    "question": "【2013】下列关于中断I/O方式和DMA方式比较的叙述中，错误的是( ).",
    "options": [
      "A. 中断I/O方式请求的是CPU处理时间，DMA方式请求求的是总线使用权",
      "B. 中断响应发生在一条指令执行结束后，DMA响应发生在一个总线事务完成后,",
      "C. 中断I/O方式下数据传送通过软件完成，DMA方3式下数据传送由硬件完成",
      "D. 中断I/O方式适用于所有外部设备，DMA方式仅适用于快速外部设备"
    ],
    "chapter": "6.4 I/O 方式",
    "id": 59,
    "image": ""
  },
  {
    "question": "【2014】若某设备中断请求的响应和处理时间为100ns，每400ns发出一次中断请求，中断响应所允许的最长延迟时间为50ns，则在该设备持续工作过程中，CPU用于该设备的I/O时间占整个CPU时间的百分比至少是( ).",
    "options": ["A. 12.5%", "B. 25%", "C. 37.5%", "D. 50%"],
    "chapter": "6.5 中断",
    "id": 60,
    "image": ""
  },
  {
    "question": "【2015】在采用中断I/O方式控制打印输出的情况下，CPU和打印控制接口中的I/O端口之间交换的信息不可能是( ).",
    "options": ["A. 打印字符", "B. 主存地址", "C. 设备状态", "D. 控制命令"],
    "chapter": "6.5 中断",
    "id": 61,
    "image": ""
  },
  {
    "question": "【2016】异常是指令执行过程中在处理器内部发生的特殊来事件，中断是来自处理器外部的请求事件.下列关于中断或异常情况的叙述中，错误的是( ).",
    "options": [
      "A. “访存时缺页“属于中断",
      "B. “整数除以0“属于异常",
      "C. “DMA传送结束“属于中断",
      "D. “存储保护错“属于异常"
    ],
    "chapter": "6.5 中断",
    "id": 62,
    "image": ""
  },
  {
    "question": "【2017】下列关于多重中断系统的叙述中，错误的是( ).",
    "options": [
      "A. 在一条指令执行结束时响应中断",
      "B. 中断处理期间CPU处于关中断状态",
      "C. 中断请求的产生与当前指令的执行无关",
      "D. CPU通过采样中断请求信号检测中断请求"
    ],
    "chapter": "6.5 中断",
    "id": 63,
    "image": ""
  },
  {
    "question": "【2018】下列关于外部I/O中断的叙述中，正确的是( ).",
    "options": [
      "A. 中断控制器按所接收中断请求的先后次序进行中断优先级排队",
      "B. CPU响应中断时，通过执行中断隐指令完成通用寄存器的保护",
      "C. CPU只有在处于中断允许状态时，才能响应外部设备的中断请求",
      "D. 有中断请求时，CPU立即暂停当前指令执行，转去执行中断服务程序"
    ],
    "chapter": "6.5 中断",
    "id": 64,
    "image": ""
  },
  {
    "question": "【2019】某设备以中断方式与CPU进行数据交换，CPU主频为1GHz，设备接口的数据缓冲寄存器为32位，设备的数据传输率为50KB/s.若每次中断开销(包括中断响应和中断处理)为1000个时钟周期，则CPU用于该设备输入/输出的时间占整个CPU时间的百分比最多是( ).",
    "options": ["A. 1.25%", "B. 2.5%", "C. 5%", "D. 12.5%"],
    "chapter": "6.5 中断",
    "id": 65,
    "image": ""
  },
  {
    "question": "【2019】下列关于DMA方式的叙述中，正确的是( ).\nI.DMA传送前由设备驱动程序设置传送参数\nII.数据传送前由DMA控制器请求总线使用权\nIII.数据传送由DMA控制器直接控制总线完成 \nIV.DMA传送结束后的处理由中断服务程序完成",
    "options": ["A. 仅I、II", "B. 仅I、III、IV", "C. 仅II、III、IV"],
    "chapter": "6.4 I/O 方式",
    "id": 66,
    "image": ""
  },
  {
    "question": "【2020】外部中断包括不可屏蔽中断(NMI)和可屏蔽中断，下列关于外部中断的叙述中错误的是( )",
    "options": [
      "A. CPU处于关中断状态时也能响应NMI请求",
      "B. 一旦可屏蔽中断请求信号有效，CPU将立即响应",
      "C. 不可屏蔽中断的优先级比可屏蔽中断的优先级高",
      "D. 可通过中断屏蔽字改变可屏蔽中断的处理优先级"
    ],
    "chapter": "6.5 中断",
    "id": 67,
    "image": ""
  },
  {
    "question": "【2020】若设备采用周期挪用DMA方式进行输入输介出，每次DMA传送的数据块大小为512字节，相应的I/0接口中有一个32位数数据缓冲寄存器，对于数据输入过程，下列叙述中错误的是( ).",
    "options": [
      "A. 每准备好32位数据，DMA控制器就发出一次总线请求",
      "B. 相对于CPU，DMA控制器的总线使用权的优先级更高",
      "C. 在整个数据块的传送过程中，CPU不可以访问主存诸器",
      "D. 数据块传送结束时，会产生“DMA传送结束“的中断请求"
    ],
    "chapter": "6.4 I/O 方式",
    "id": 68,
    "image": ""
  },
  {
    "question": "【2021】异常事件在当前指令执行过程中进行检测，中断请求则在当前指令执行后进行检测下列事件中，相应处理程序执行后，必须回到当前指令重新执行的是( ).",
    "options": ["A. 系统调用", "B. 页缺失", "C. DMA传送结束", "D. 打印机缺纸"],
    "chapter": "6.5 中断",
    "id": 69,
    "image": ""
  },
  {
    "question": "【2021】下列是关于多重中断系统中CPU响应中断的叙述，其中错误的是( ).",
    "options": [
      "A. 仅在用户态(执行用户程序)下，CPU才能检测和响应中新",
      "B. CPU只有在检测到中断请求信号后，才会进入中断响应周期",
      "C. 进入中断响应周期时，CPU一定处于中断允许(开中断)状态",
      "D. 若CPU检测到中断请求信号，则一定存在未被屏蔽的中断源请求信号"
    ],
    "chapter": "6.5 中断",
    "id": 70,
    "image": ""
  }
]
